<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Koinos Smart Contract Development Guide</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 2em;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            padding: 1em;
            background-color: #f9f9f9;
            color: #333;
        }
        h1, h2, h3 {
            color: #1a1a1a;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        h1 {
            border-bottom: 2px solid #ccc;
            padding-bottom: 0.3em;
        }
        h2 {
            border-bottom: 1px solid #ddd;
            padding-bottom: 0.2em;
        }
        code {
            font-family: monospace;
            background-color: #eee;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-size: 0.95em;
        }
        pre {
            background-color: #eee;
            padding: 1em;
            border-radius: 4px;
            overflow-x: auto;
            border: 1px solid #ddd;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 0.9em;
        }
        ul, ol {
            margin-left: 2em;
            padding-left: 0;
        }
        li {
            margin-bottom: 0.5em;
        }
        strong {
          font-weight: bold;
        }
        blockquote {
            border-left: 4px solid #ccc;
            padding-left: 1em;
            margin-left: 0;
            font-style: italic;
            color: #555;
        }
    </style>
</head>
<body>

    <h1>Koinos Smart Contract Development Guide</h1>

    <h2>Introduction</h2>
    <p>
        Koinos is a feeless, upgradeable smart contract platform that uses a WebAssembly (WASM) virtual machine. This guide provides a comprehensive overview of developing smart contracts on Koinos, covering both AssemblyScript (TypeScript for WASM) and C++ development. We will explore the unique Koinos architecture (mana-based resource model and modular upgradeable design), walk through the contract lifecycle (from writing Protobuf definitions and code, to compiling, deploying, and interacting via CLI or wallet), and provide full code examples. The guide also includes details on Koinos-specific concepts (like entry points, system calls, and governance) and a glossary of common terms. All code examples are provided in a copy-paste ready format, with explanations that balance human readability and technical precision.
    </p>

    <h2>Koinos Architecture</h2>
    <p>
        Koinos takes a novel approach to blockchain architecture that differentiates it from EVM-based chains. Understanding these differences is critical:
    </p>

    <h3>Feeless Mana-Based Execution</h3>
    <p>
        Unlike Ethereum’s gas fee model, Koinos has no transaction fees. Instead, it uses a Mana system. Mana is a regenerative resource attached to <code>KOIN</code> tokens, giving users the ability to transact without paying fees. Each <code>KOIN</code> token carries a fixed amount of Mana (1 <code>KOIN</code> at 100% charge provides 1 Mana). When you execute transactions or smart contract calls, you consume a portion of your Mana proportional to the resources used. This Mana automatically recharges over time (up to 20% of total Mana per day, achieving full recharge in 5 days). Because Mana regenerates, users never permanently spend tokens to run contracts – they only need to hold <code>KOIN</code> to gain continuous resource capacity. If Mana is depleted, the user must wait for recharge (or acquire more <code>KOIN</code>) before making further transactions. This approach makes Koinos feeless from the user perspective, significantly lowering barriers to entry and enabling free-to-use dApps. Important points about Mana:
    </p>
    <ul>
        <li><strong>No Gas or Fees:</strong> Contract execution “costs” Mana but not <code>KOIN</code>. The example of uploading a contract showed it cost 0.386 Mana, but spent 0 actual <code>KOIN</code>.</li>
        <li><strong>Intrinsic to KOIN:</strong> Mana is tied to <code>KOIN</code> holdings. If you transfer <code>KOIN</code>, the Mana goes with it; <code>KOIN</code> cannot be transferred if it’s partially depleted (you must wait until its Mana is full).</li>
        <li><strong>Regeneration:</strong> Mana recovers over time (20% per day), so users eventually get back the capacity to transact.</li>
        <li><strong>Resource Credits (RC):</strong> In Koinos, advanced features like RC limits and payer semantics allow one account to cover Mana costs for another or to set usage limits. For example, a dApp developer can sponsor users’ Mana by designating themselves as the payer for a transaction (so the dApp’s Mana is used instead of the user’s). This provides flexibility in how Mana costs are managed, though typical scenarios don’t require users to configure this.</li>
    </ul>
    <p>
        Overall, Mana ensures Koinos smart contracts are accessible without continuous token expenditure, a key differentiator from gas-fee models.
    </p>

    <h3>Modular, Upgradeable Design (vs. Monolithic Chains)</h3>
    <p>
        Koinos is built for modularity and upgradeability. Most blockchain features that are “hard-coded” in other networks (consensus rules, token logic, governance rules, etc.) are implemented as smart contracts on Koinos. There are two types of smart contracts on Koinos:
    </p>
    <ul>
        <li><strong>System Contracts:</strong> These are privileged contracts that provide core blockchain functionality (such as the native <code>KOIN</code> token, resource mana management, governance, etc.). System contracts operate in a special system space allowing them to modify core blockchain state. They can be upgraded via on-chain governance.</li>
        <li><strong>User Contracts:</strong> These are decentralized application contracts deployed by developers/users. They run in user space (isolated storage) and cannot affect global system state directly. User contracts typically implement dApp logic (tokens, games, etc.) and are owned by the deploying account.</li>
    </ul>
    <p>
        <strong>Forkless Upgrades:</strong> Because core functionality is in system contracts, Koinos can evolve without hard forks. Upgrades to system contracts are proposed on-chain and approved by block producers via a governance process (on-chain voting). Once approved, a new version of a system contract is uploaded, and the change propagates across the network automatically. This means the blockchain can upgrade itself (e.g. change consensus parameters, fix bugs, add features) by consensus, rather than requiring node software updates and chain forks. As a result, governance proposals and voting thresholds (e.g. 75% supermajority for critical changes) determine upgrades, making governance the bottleneck of change instead of code releases.
    </p>
    <p>
        <strong>Upgradeable User Contracts:</strong> Regular smart contracts on Koinos are also upgradeable by design. A smart contract lives at a blockchain address (more on the account model below), and the owner of that address (initially the deployer) can upload new WASM code to it at any time. In other words, contract code is mutable unless intentionally locked. By default, when you deploy a contract, the private key of the deployment address can sign another upload transaction to replace the code at that address. This is a sharp contrast to Ethereum where contract code is immutable once deployed (unless a proxy pattern is used). Koinos does allow truly immutable contracts as well—one can implement a custom permission (via the Authority system call) to refuse further upgrades, effectively “freezing” the code. But if not explicitly locked, upgrading a user contract is as simple as deploying a new WASM to the same address. This flexibility is powerful for developers to fix issues or improve contracts over time, but it also means contract authors have control to change logic, which users should be aware of when interacting with third-party contracts.
    </p>

    <h3>WASM and Multi-Language Support</h3>
    <p>
        Koinos uses a WASM-based virtual machine (specifically, the Fizzy WASM engine) to execute smart contracts. This means any language that can compile to WebAssembly can potentially be used to write Koinos contracts. In practice, Koinos currently provides SDKs for C++ and AssemblyScript (a TypeScript-like language) to write contracts. The blockchain itself is agnostic to the source language – it only sees the compiled WASM. This design contrasts with Ethereum’s EVM, which primarily targets Solidity (or Vyper) and uses an Ethereum-specific bytecode.
    </p>
    <p>
        <strong>AssemblyScript vs C++:</strong> AssemblyScript (AS) is a high-level, developer-friendly option leveraging TypeScript syntax, which lowers the learning curve for JavaScript/TypeScript developers. The majority of new Koinos contracts are written in AssemblyScript. C++ was the first SDK available and offers performance and control, but requires more expertise. Both languages ultimately produce a WASM module that runs in the Koinos VM. You can choose either based on your familiarity and project needs. We will provide examples in both.
    </p>
    <p>
        <strong>System Calls:</strong> In Koinos, contracts interact with the blockchain through system calls (also known as Koinos APIs). These are functions provided by the blockchain runtime for common operations: reading contract arguments, getting the caller or contract ID, reading/writing the contract’s state database, emitting events (logs), verifying signatures, etc. The SDKs wrap these low-level system calls for ease of use (e.g., providing a <code>System</code> class with static methods). For instance, a contract uses <code>System.getArguments()</code> to retrieve its input data, or <code>System.putObject()</code> to write to storage, and <code>System.exit()</code> to return from execution with a success/error code. We'll see these in the code examples. The key point is that Koinos’s core is minimal – almost everything a contract might do is an API call, which in turn is implemented by system contracts or the blockchain microservices. This gives developers a lot of power to integrate with the chain’s features in a straightforward way.
    </p>

    <h3>Accounts and Addresses Model</h3>
    <p>
        On Koinos, accounts and contracts share the same address space – there is no strict separation between “EOA” (externally owned accounts) and contract accounts as in Ethereum. Any address (which is derived from a public key) can have a smart contract uploaded to it. In fact, when you deploy a contract, you are effectively turning a wallet address into a contract. The CLI output below illustrates this:
    </p>
    <blockquote>
        We created a new wallet and uploaded a contract to it. The CLI reported: “Contract uploaded with address 19yp...RQLE. ... This means that the address 19yp...RQLE is the address of the wallet we created earlier, but it is also the address of the contract. Smart contracts are users in Koinos.”
    </blockquote>
    <p>
        In other words, the deployment process doesn’t generate a new address; it uses an existing one. The contract runs under the identity of that address. This model has a few implications:
    </p>
    <ul>
        <li><strong>One Address = One Private Key (optionally with Contract Code):</strong> If you have the private key, you control the address and thus can deploy or upgrade code on it. If an address has no code, it’s a normal user account. If it has code, it’s a contract account (which can still sign transactions if it has a private key, though typically contracts act only when called).</li>
        <li><strong>Authority and Privileges:</strong> Because contracts may need to restrict who can call certain entry points (or who can upgrade them), Koinos provides an authority system call and a standard interface for custom authorization. By default, when a contract is called, the blockchain checks if the caller is authorized (e.g., for token transfers, the caller must be the token holder or an approved spender). Contracts can implement an <code>authorize()</code> entry point (as part of the Koinos authority standard) to override default authorization logic. For upgrades, by default only the address’s own key can upload new code; if a contract wants to disable upgrades, it could implement a custom <code>authorize</code> that rejects <code>UPLOAD_CONTRACT</code> operations from everyone, including the owner (making it immutable).</li>
        <li><strong>No Distinction in Transfers:</strong> Any address can hold <code>KOIN</code> tokens or other tokens, whether it’s a user or a contract. For example, a contract can own tokens and act on them, and a user can send tokens to a contract address.</li>
    </ul>
    <p>
        This unified account model is powerful (e.g., you could even have a contract that is also used as a regular account by its owner), but typical usage is to treat accounts as either user-controlled or code-controlled, not both simultaneously.
    </p>

    <h3>Comparison to EVM Chains</h3>
    <p>
        In summary, how Koinos differs from a typical Ethereum-like chain:
    </p>
    <ul>
        <li><strong>Fee Model:</strong> Koinos uses Mana (recharging resource) instead of gas fees. Users don’t lose tokens to fees.</li>
        <li><strong>Upgradeability:</strong> All Koinos smart contracts (even system-level logic) are upgradeable (via governance for system contracts, via owner re-deployment for user contracts) by default. In Ethereum, core protocol changes need forks, and user smart contracts are immutable once deployed (unless using proxy patterns).</li>
        <li><strong>Language and VM:</strong> Koinos runs WASM, allowing developers to use languages like C++ and AssemblyScript. Ethereum’s EVM is a bespoke VM mainly used via Solidity. WASM also means more consistency with web standards and potential for broader language support.</li>
        <li><strong>Accounts:</strong> No separate contract vs EOA distinction – any address can be a contract.</li>
        <li><strong>Governance:</strong> On-chain governance is built-in to Koinos for protocol upgrades (the blockchain is effectively a DAO controlling its own evolution). Ethereum has off-chain governance for changes (social coordination for forks and EIPs).</li>
        <li><strong>Consensus:</strong> Koinos uses a unique Proof-of-Burn consensus (block producers compete by provably burning KOIN), which is implemented as a system contract. While not directly relevant to contract development, it’s another example of a modular feature. Ethereum currently uses Proof-of-Stake with external validators.</li>
    </ul>
    <p>
        With these fundamentals in mind, let’s move on to actually building and deploying contracts on Koinos.
    </p>

    <h2>Smart Contract Development Lifecycle</h2>
    <p>
        Developing a Koinos smart contract involves several steps. We’ll outline the typical workflow and then delve into specifics for AssemblyScript and C++:
    </p>
    <ol>
        <li><strong>Set Up Environment & Tools</strong> – Install the SDK (AssemblyScript SDK or C++ SDK), Koinos CLI, and any prerequisites (e.g., Node.js, Protocol Buffers compiler, etc.).</li>
        <li><strong>Define Contract Interface (ABI)</strong> – Specify your contract’s entry points (functions), arguments, and return types using Protocol Buffers (Protobuf) definitions. This will be used to generate the contract’s ABI (Application Binary Interface) and data classes.</li>
        <li><strong>Implement Contract Logic</strong> – Write the smart contract code (in AssemblyScript <code>.ts</code> or C++ <code>.cpp</code>) using the SDK, implementing the desired behaviors for each entry point.</li>
        <li><strong>Compile and Build</strong> – Compile the code to WebAssembly and generate the ABI file. The output will include a <code>.wasm</code> file (the contract bytecode) and an <code>.abi</code> JSON file (or binary <code>.abi</code>) describing the contract’s interface for clients.</li>
        <li><strong>Deploy (Upload) Contract</strong> – Use Koinos CLI or a library (Koilib) to upload the WASM to the blockchain. This associates the compiled contract with an address (usually the developer’s address or a new address).</li>
        <li><strong>Register the ABI (for CLI usage or wallets)</strong> – Tell client tools about the contract’s ABI so they know how to format calls. In Koinos CLI, for example, you register the contract’s address and ABI file to be able to call its functions by name.</li>
        <li><strong>Interact with the Contract</strong> – Call the contract’s entry points using CLI commands, via a wallet like Kondor, or programmatically using libraries (Koilib). You can perform read-only calls (which do not consume Mana or create a transaction) or state-changing calls (which create a transaction that uses Mana).</li>
        <li><strong>Upgrade (if needed)</strong> – Repeat steps 3–5 to upload a new version of the contract code to the same address (if you want to change functionality). If the contract is system-critical or you want formal governance for changes, consider using the governance mechanism or authority restrictions appropriately.</li>
    </ol>
    <p>
        We will now go through these steps with more detail, including actual examples in AssemblyScript and C++.
    </p>

    <h2>Setting Up Development Environment</h2>

    <h3>AssemblyScript SDK Setup</h3>
    <p>
        The official Koinos AssemblyScript SDK (<code>koinos-sdk-as</code>) requires Node.js (v16+). You can install it via npm or yarn:
    </p>
<pre><code class="language-bash"># Install the Koinos AS SDK as a dependency in your project
npm install koinos-sdk-as   # or: yarn add koinos-sdk-as
</code></pre>
    <p>
        Additionally, install the Koinos AssemblyScript CLI tool <code>koinos-sdk-as-cli</code> (which comes with the SDK package). This CLI helps bootstrap projects and generate necessary files. Ensure you have Protocol Buffers (<code>protoc</code>) installed as well, since the SDK uses it to generate code from <code>.proto</code> definitions.
    </p>

    <h3>C++ SDK Setup</h3>
    <p>
        The Koinos C++ SDK (<code>koinos-sdk-cpp</code>) requires a WebAssembly cross-compilation setup. You’ll need to download the WASI SDK (WebAssembly System Interface SDK) release for your platform (e.g., <code>wasi-sdk</code> 12.0) and set an environment variable <code>KOINOS_WASI_SDK_ROOT</code> to its path. Also set <code>KOINOS_SDK_ROOT</code> to the directory where you want to install the Koinos SDK. Then build the Koinos C++ SDK from source:
    </p>
<pre><code class="language-bash">git clone https://github.com/koinos/koinos-sdk-cpp.git
cd koinos-sdk-cpp
mkdir build && cd build
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$KOINOS_SDK_ROOT ..
make -j install
</code></pre>
    <p>
        This installs libraries for C and C++ system call interfaces (e.g., <code>koinos_api_cpp</code>) and a CMake toolchain file for building contracts. To create your own C++ contract project, you will use this toolchain in your CMake configuration. Make sure to link against the Koinos SDK libraries (<code>koinos_api</code>, <code>koinos_api_cpp</code>, <code>koinos_wasi_api</code>, etc.) as indicated in the SDK docs.
    </p>

    <h3>Koinos CLI</h3>
    <p>
        Install the Koinos CLI tool (often just called <code>koinos-cli</code>). This might be available via npm (as part of koilib tools) or as a standalone binary. For example, if using npm:
    </p>
<pre><code class="language-bash">npm install -g @koinos/cli
</code></pre>
    <p>
        The CLI is essential for creating wallets, connecting to a node (local or testnet), and issuing commands to deploy and call contracts.
    </p>

    <h3>Kondor Wallet (for Browser)</h3>
    <p>
        If you plan to interact with contracts via a web application, set up Kondor, the Koinos browser wallet (a Chrome/Brave extension). Kondor manages your keys and can approve transactions initiated from web apps. It works with the Koilib JavaScript library to enable DApp integration. (We’ll cover usage later in the interaction section.)
    </p>

    <h3>Local Node or Testnet</h3>
    <p>
        For development, you can use the Harbinger testnet (Koinos public test network) or run a local Koinos node. The easiest way to get a local blockchain is using the <code>local-koinos</code> Docker setup, but for most contract testing, the public testnet is convenient. Ensure you have some test <code>KOIN</code> (tKOIN) – the Learn Koinos tutorials show how to use a faucet.
    </p>
    <p>
        With the tools ready, let’s create a contract.
    </p>

    <h2>Writing the Contract Interface (Protobuf ABI Definition)</h2>
    <p>
        Koinos uses Protocol Buffers to define the data structures for contract arguments and return values. This <code>.proto</code> definition is the source of truth for your contract’s interface, and the SDK will use it to generate the ABI.
    </p>
    <p>
        For each entry point (function) your contract exposes, you typically define two messages in the proto file: <code>{function}_arguments</code> and <code>{function}_result</code>. For example, imagine a simple Calculator contract with entry points <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code> each taking two 64-bit integers and returning a 64-bit integer result. The <code>calculator.proto</code> might look like:
    </p>
<pre><code class="language-protobuf">syntax = "proto3";
package calculator;

// Arguments for each entry point:
message add_arguments { int64 x = 1; int64 y = 2; }
message add_result    { int64 value = 1; }

message sub_arguments { int64 x = 1; int64 y = 2; }
message sub_result    { int64 value = 1; }

message mul_arguments { int64 x = 1; int64 y = 2; }
message mul_result    { int64 value = 1; }

message div_arguments { int64 x = 1; int64 y = 2; }
message div_result    { int64 value = 1; }
</code></pre>
    <p>
        This defines the input and output of each function. By convention, we use <code>{name}_arguments</code> and <code>{name}_result</code> in Protobuf. If a function takes no arguments, you can define an empty message (or omit it and use a generic empty placeholder). If a function returns nothing, you might still define a result message for consistency (or use an empty result).
    </p>
    <p>
        For a simpler example, consider a HelloWorld contract with one function <code>hello</code> that takes a string and returns a greeting string:
    </p>
<pre><code class="language-protobuf">syntax = "proto3";
package myapp.hello;

message hello_arguments { string name = 1; }
message hello_result    { string greeting = 1; }
</code></pre>
    <p>
        Once you create the <code>.proto</code> file, the AssemblyScript CLI can generate TypeScript classes for these messages and also scaffold boilerplate contract code. In an AssemblyScript project, ensure the proto file is placed in the <code>assembly/proto/</code> directory of your project (e.g., <code>assembly/proto/hello.proto</code>). Then run:
    </p>
<pre><code class="language-bash"># Generate AssemblyScript types from the proto
yarn exec koinos-sdk-as-cli generate-contract-proto   # inside the project folder
</code></pre>
    <p>
        This uses <code>protoc</code> with the AssemblyScript plugin to create TS classes (e.g., <code>hello_arguments</code> and <code>hello_result</code> classes in the <code>assembly/</code> directory). It will also generate an initial <code>index.ts</code> and a <code>&lt;ContractName&gt;.boilerplate.ts</code> if you run <code>generate-contract-as</code>. The boilerplate contains the structure of the contract's dispatch (mapping entry point identifiers to your functions).
    </p>
    <p>
        The entry point identifiers are worth noting: Koinos doesn’t natively use human-readable function names on-chain. Instead, each entry point is identified by a 32-bit integer (typically derived from a hash of the function name for uniqueness). The ABI will map the human name to this number. For instance, in the generated ABI JSON for the KOIN token contract, the <code>transfer</code> method is listed with an entry point <code>0x62efa292</code>. You usually don’t worry about these IDs, as the SDK and CLI handle them (the CLI, after registering the ABI, lets you call by name, and under the hood it uses the entry point ID). Just be aware that in logs or low-level interfaces, you might see entry point numbers instead of names.
    </p>
    <p>
        In the AssemblyScript SDK, the boilerplate will typically create a <code>switch</code> statement in <code>index.ts</code> that checks <code>contractArgs.entry_point</code> against these hex IDs and dispatches to the appropriate function, as shown later in our example.
    </p>

    <h2>Implementing Contract Logic (AssemblyScript)</h2>
    <p>
        Now you write the actual logic of your contract – i.e., what each entry point function does. With AssemblyScript, you will create a class that represents your contract, implement methods corresponding to each entry point, and possibly use the Koinos SDK’s system call wrappers for state storage or other blockchain interactions.
    </p>
    <p>
        Let’s continue with the HelloWorld example in AssemblyScript. We’ve defined the proto with <code>hello_arguments</code> and <code>hello_result</code>. We will implement a contract that when called with a name, returns "Hello, &lt;name&gt;!".
    </p>
    <p><strong>AssemblyScript Contract Example:</strong></p>
<pre><code class="language-typescript">// File: assembly/HelloWorld.ts
import { System, Protobuf, StringBytes } from "@koinos/sdk-as";
import { hello as ProtoNS } from "./proto/hello";  // Import the proto namespace/types

export class HelloWorld {
  // The hello function implementation
  hello(args: ProtoNS.hello_arguments): ProtoNS.hello_result {
    const name = args.name;
    // Construct the greeting
    const greetingMsg = `Hello, ${name}!`;
    // Prepare result object
    const res = new ProtoNS.hello_result();
    res.greeting = greetingMsg;
    return res;
  }
}
</code></pre>
    <p>A few notes on the code above:</p>
    <ul>
        <li>We import <code>System</code> and <code>Protobuf</code> from the SDK. <code>System</code> provides system calls (like logging, storage, etc.), and <code>Protobuf</code> provides encode/decode functions if needed (but the SDK also offers generated encode/decode on the classes).</li>
        <li>We also import <code>StringBytes</code> which can help with string&lt;-&gt;Uint8Array conversion if needed (not used in this simple example).</li>
        <li>The <code>hello</code> method takes a <code>hello_arguments</code> object and returns a <code>hello_result</code> object. These classes were generated from our proto and contain the fields we defined.</li>
        <li>We simply form a string and set it as the result’s <code>greeting</code>.</li>
    </ul>
    <p>The AssemblyScript SDK also allows using system calls for persistent storage or events:</p>
    <ul>
        <li><strong>State Storage:</strong> Each contract has a key-value store (its object space) for persistent data. For example, if our contract needed to store a counter, we could use <code>System.putObject(object_space, key, valueBytes)</code> and <code>System.getObject(object_space, key)</code> to write/read. The <code>object_space</code> for user contracts is typically defined with <code>system=false</code> and <code>zone = contract’s address bytes</code>. The SDK likely provides a simplified API, but underlying it uses those calls. In AssemblyScript, to store a string or number, you would convert it to <code>Uint8Array</code> (bytes) and use <code>System.putObject</code>. For example:</li>
    </ul>
<pre><code class="language-typescript">const space = new System.ObjectSpace(false, this.contractId, 0); // id=0 for primary space
System.putBytes(space, StringBytes.stringToBytes("greeting"), StringBytes.stringToBytes(greetingMsg));
</code></pre>
    <p>This would store the greeting under key "greeting".</p>
    <ul>
        <li><strong>Events/Logs:</strong> You can emit events by writing to the event log. In Koinos, an event is just a record with your contract ID, an event name, and some data. The SDK might provide <code>System.event</code> or similar. Alternatively, you can use <code>System.log(message)</code> for a basic textual log (which appears in transaction receipt logs). For structured events, typically you’d define an event protobuf message and call <code>System.event</code> with the encoded data and perhaps an event name. (For brevity we won’t delve into event specifics here.)</li>
    </ul>
    <p>After writing the contract logic, we need to tie it into the dispatch mechanism. The SDK’s <code>generate-contract-as</code> command often produces an <code>index.ts</code> that looks like this:</p>
<pre><code class="language-typescript">import { System, Protobuf } from "@koinos/sdk-as";
import { HelloWorld as ContractClass } from "./HelloWorld";
import { hello as ProtoNS } from "./proto/hello";

export function main(): i32 {
  const contractArgs = System.getArguments(); // get entry point and args buffer
  const c = new ContractClass();
  let retBuf = new Uint8Array(0);

  switch (contractArgs.entry_point) {
    case 0x6d4ce63c: {  // some 32-bit ID for "hello"
      const args = Protobuf.decode&lt;ProtoNS.hello_arguments&gt;(
        contractArgs.args, ProtoNS.hello_arguments.decode
      );
      const res = c.hello(args);
      retBuf = Protobuf.encode(res, ProtoNS.hello_result.encode);
      break;
    }
    default: {
      System.exit(1); // unknown entry point, error
      break;
    }
  }

  System.exit(0, retBuf);
  return 0;
}
main();
</code></pre>
    <p>
        This is an illustrative snippet based on typical boilerplate (the actual entry point hex will differ). It obtains the raw arguments, dispatches to the correct method of our <code>HelloWorld</code> class, encodes the result, and uses <code>System.exit(0, retBuf)</code> to return successfully with that result. <code>System.exit(code, buffer)</code> is how a contract ends execution: exit code 0 means success (and the buffer is returned as the result), while a non-zero code indicates an error which will revert any state changes done by the contract. In our case, if an unknown function ID is called, we exit with 1 (causing the call to fail). If we wanted to enforce any runtime checks (e.g., division by zero in a calculator) we could similarly call <code>System.exit( &lt;non-zero&gt; )</code> to abort.
    </p>
    <p>
        <strong>Note:</strong> You usually don’t need to manually write the <code>main()</code> and dispatch switch for AssemblyScript; the CLI generator handles it. But it’s important to understand it, especially if debugging or writing in C++ (where you will write a similar dispatch logic yourself).
    </p>
    <p>After implementing the contract, run the build:</p>
<pre><code class="language-bash"># Compile the contract to WASM and generate ABI
# (Make sure to execute inside the project directory)
koinos-sdk-as-cli build-all release hello.proto
</code></pre>
    <p>This single command will:</p>
    <ul>
        <li>Compile your AssemblyScript code to a WASM module (in <code>build/release/contract.wasm</code>).</li>
        <li>Generate the <code>.abi</code> file (Application Binary Interface) in the <code>abi/</code> folder, as well as a human-readable JSON representation of the ABI.</li>
        <li>Ensure the <code>index.ts</code> and boilerplate are up-to-date.</li>
    </ul>
    <p>The output of a successful build includes files:</p>
    <ul>
        <li><code>contract.wasm</code> (the compiled contract bytecode)</li>
        <li><code>hello.abi</code> (binary ABI description)</li>
        <li><code>hello-abi.json</code> (JSON ABI)</li>
        <li>(Plus any intermediate files like the generated TS from proto, which we saw in the <code>assembly</code> folder).</li>
    </ul>
    <p>You now have everything needed to deploy and use the contract.</p>

    <h2>Implementing Contract Logic (C++)</h2>
    <p>
        If you choose to develop in C++, the overall flow is similar: define proto messages for your interface (you can use the same <code>.proto</code> and use a C++ Protobuf compiler to generate C++ classes, or manually define serialization). The Koinos C++ SDK does not auto-generate a dispatch for you; you will write a <code>main()</code> function that uses the Koinos system call C/C++ API to read the entry point, decode arguments, and encode results.
    </p>
    <p>
        Let’s create the same HelloWorld contract in C++ for illustration. We’ll use Protobuf as well, assuming you have the C++ classes generated for <code>hello_arguments</code> and <code>hello_result</code> (from the <code>.proto</code> earlier). The Koinos C++ SDK provides functions to get the call arguments and to exit.
    </p>
    <p><strong>C++ Contract Example:</strong></p>
<pre><code class="language-cpp">// File: hello.cpp
#include &lt;koinos/chain/system_calls.hpp&gt;   // Koinos system call interface
#include "hello.pb.h"    // Generated by protoc from hello.proto (contains hello::hello_arguments, hello::hello_result)

using namespace koinos::chain;  // contains System calls like get_arguments, exit

extern "C" __attribute__((visibility("default"))) int main() {
  // Retrieve contract call arguments (entry point and payload)
  auto args_ptr = get_arguments();  // returns pointer to args in memory
  size_t args_size = get_arguments_size();
  std::string args_bytes(args_size, '\0');
  chain::read_buffer(args_ptr, args_bytes.data(), args_size);
  uint32_t entry = get_entry_point();  // entry point ID of the call

  std::string ret; // buffer for return data
  int32_t exit_code = 0;

  if (entry == 0x6d4ce63c) {  // suppose this is the ID for "hello"
    // Decode arguments from bytes into a hello_arguments object
    hello::hello_arguments arg_obj;
    if (!arg_obj.ParseFromString(args_bytes)) {
      exit(1); // parsing error
    }
    std::string name = arg_obj.name();

    // Business logic: create greeting
    std::string greeting = "Hello, " + name + "!";

    // Encode result
    hello::hello_result res_obj;
    res_obj.set_greeting(greeting);
    res_obj.SerializeToString(&ret);
    exit_code = 0;
  } else {
    // Unknown entry point
    exit_code = 1;
  }

  if (exit_code == 0) {
    exit(0, ret.data(), ret.size());  // exit with success and return buffer
  } else {
    exit(exit_code);
  }
  return 0;
}
</code></pre>
    <p>
        <strong>Explanation:</strong> This C++ code uses pseudo-APIs similar to those provided by the Koinos SDK:
    </p>
    <ul>
        <li><code>get_entry_point()</code> and <code>get_arguments()</code> are system calls to retrieve the entry point ID and argument pointer. (In reality, the Koinos SDK might provide a single call that returns both in a struct, but for clarity we do them separately).</li>
        <li>We assume <code>hello.pb.h</code> defines classes from the proto (using the Google Protobuf library). We parse the incoming args into <code>hello_arguments</code> and then construct <code>hello_result</code>.</li>
        <li>We call <code>exit(code, buf, size)</code> to return from the contract. The <code>exit</code> system call in C++ can be overloaded: <code>exit(code)</code> with no buffer, or <code>exit(code, data_ptr, data_size)</code> to return data.</li>
    </ul>
    <p>
        The C++ SDK actually offers some conveniences (like a <code>koinos::chain::protobuf</code> namespace to help with serialization, and maybe a wrapper for reading arguments in one go). But the above demonstrates the core of it. You would compile this C++ code with CMake, using the Koinos WASM toolchain:
    </p>
    <p><strong>CMakeLists snippet:</strong></p>
<pre><code class="language-cmake">project(hello_contract)

find_package(koinos.cdt)  # find the Koinos Contract Development Toolkit

add_executable(hello.wasm hello.cpp)

target_link_libraries(hello.wasm koinos_api_cpp koinos_api)  # link Koinos SDK libs
</code></pre>
    <p>Then run cmake with the toolchain:</p>
<pre><code class="language-bash">cmake -DCMAKE_TOOLCHAIN_FILE=$KOINOS_SDK_ROOT/cmake/koinos-wasm-toolchain.cmake \
      -DCMAKE_BUILD_TYPE=Release .
make
</code></pre>
    <p>
        This should produce <code>hello.wasm</code>. You would also have to produce a matching ABI file. Currently, the AssemblyScript SDK provides tools to generate the ABI JSON from the proto. For C++, you might manually create the ABI JSON or use the AssemblyScript CLI just to generate the <code>.abi</code> from your proto (since ABI is language-agnostic). The ABI JSON for our hello contract would look like:
    </p>
<pre><code class="language-json">{
  "methods": {
    "hello": {
      "argument": "myapp.hello.hello_arguments",
      "return":   "myapp.hello.hello_result",
      "entry_point": "0x6d4ce63c",
      "description": "Returns a greeting for the given name",
      "read_only": true
    }
  },
  "types": "&lt;base64 protobuf descriptors&gt;"
}
</code></pre>
    <p>
        This is similar to the example in the docs (for the KOIN token contract) but simplified to one method. The "types" field is a base64 encoding of the proto descriptor, allowing clients to decode/encode data without the original <code>.proto</code> file.
    </p>

    <h2>Compiling and Building (Summary)</h2>
    <p>
        At this stage, regardless of language, you have a compiled <code>contract.wasm</code> and an ABI file describing the contract interface. Summarizing:
    </p>
    <ul>
        <li><strong>AssemblyScript:</strong> use <code>koinos-sdk-as-cli build-all release &lt;your.proto&gt;</code> to compile and get artifacts.</li>
        <li><strong>C++:</strong> use <code>cmake/make</code> to compile to WASM, and ensure you prepare the ABI (possibly using a script or the AssemblyScript tool for ABI generation from the same proto).</li>
    </ul>
    <p>
        Now we are ready to deploy the contract to a Koinos blockchain (testnet or mainnet).
    </p>

    <h2>Contract Deployment and Interaction</h2>

    <h3>Deploying (Uploading) the Contract</h3>
    <p>
        Deploying a Koinos contract is often referred to as uploading the contract. You will need:
    </p>
    <ul>
        <li>A Koinos wallet address (with sufficient Mana available).</li>
        <li>The compiled <code>.wasm</code> file.</li>
        <li>(Optionally) the <code>.abi</code> file for registering the interface in clients.</li>
    </ul>
    <p>
        Using Koinos CLI is straightforward:
    </p>
    <ol>
        <li>Open your wallet in the CLI and connect to a node:</li>
    </ol>
<pre><code class="language-bash">$ koinos-cli
> open wallet.mywallet mypassword   # opens a local wallet file
Opened wallet: wallet.mywallet
> connect https://api.koinos.io    # connect to mainnet (or a testnet endpoint)
Connected to endpoint https://api.koinos.io
</code></pre>
    <p>Now the CLI is using your wallet (your address is “unlocked” for signing) and is connected to the blockchain.</p>
    <ol start="2">
      <li>Upload the WASM:</li>
    </ol>
<pre><code class="language-bash">> upload build/release/contract.wasm
Contract uploaded with address 19yp497RPiuWwsNUWp9cHWfbWUupHsRQLE
Transaction with ID 0x12209604... submitted.
Mana cost: 0.38643078 (Disk: 16472, Network: 17562, Compute: 177948)
</code></pre>
    <p>
        As seen above, the CLI output confirms the contract was uploaded to address <code>19yp...RQLE</code>, which is actually the address of the currently open wallet. The CLI explicitly notes: “The contract id will be the public address of the currently open wallet.” In this example, our wallet’s address was used as the contract’s address. The transaction ID and Mana cost are displayed (no KOIN burned, just Mana consumed).
    </p>
    <p>
        If you wanted to deploy to a new address (so your user wallet is not the contract owner), you would create a new wallet, open it, and fund it with some Mana (KOIN) or use a payer account. The Koilib library example shows how you can deploy a contract to a new address by setting a different payer for the transaction.
    </p>
    <p>
        The CLI <code>upload</code> command only needs the WASM file; it does not take the ABI file as input, because the ABI is not stored on-chain – it’s for off-chain usage. The blockchain now has your code stored and associated with that address.
    </p>
    <p>
        <strong>(Optional) Verify Deployment:</strong> You can check a block explorer (like KoinosBlocks for mainnet or its testnet counterpart) and search the contract address or transaction ID to ensure it was included. On KoinosBlocks, a contract address page will show the contract’s registered read-only methods if it recognizes an ABI, otherwise just the raw calls.
    </p>
    <p>
        <strong>Understanding Addresses and Ownership:</strong> As mentioned, the deploying address becomes the contract’s address. That address is now both an identifier for the contract and still a wallet with a private key (yours). By default, only your key is authorized to upload (update) code on that address. If someone else tries to upload a contract to your address, the system’s authorization checks will reject it. Similarly, your contract can call <code>System.getCaller()</code> in an authorize function to ensure only you (the owner) can perform certain privileged actions within the contract.
    </p>
    <p>
        One more detail: The Koinos block size currently limits contract WASM size to 200 KB. If your contract exceeds that, you might need to split logic into multiple contracts.
    </p>
    <p>
        Now that the contract is deployed, the next step is to make its functionality available to users (or to yourself) via the ABI.
    </p>

    <h3>ABI Registration and CLI Commands</h3>
    <p>
        After uploading, if you want to interact via the Koinos CLI with human-friendly commands, register the contract’s ABI:
    </p>
<pre><code class="language-bash">> register hello 19yp497RPiuWwsNUWp9cHWfbWUupHsRQLE abi/hello.abi
Contract 'hello' at address 19yp497RPiuWwsNUWp9cHWfbWUupHsRQLE registered
</code></pre>
    <p>
        The format is <code>register &lt;alias&gt; &lt;contract_address&gt; &lt;path_to_abi_file&gt;</code>. We chose alias "hello" for convenience. Now the CLI knows that alias corresponds to that address and has the definitions of its methods. It will add new commands to the CLI for each entry point:
    </p>
<pre><code class="language-bash">> list
...
hello.hello   - Returns a greeting for the given name
...
</code></pre>
    <p>The CLI pulled the method description from the ABI. We can use <code>help</code> on any method:</p>
<pre><code class="language-bash">> help hello.hello
Returns a greeting for the given name
Usage: hello.hello &lt;name:string&gt;
</code></pre>
    <p>And we can finally call the contract:</p>
<pre><code class="language-bash">> hello.hello Koinos
value: "Hello, Koinos!"
</code></pre>
    <p>
        The CLI recognized that <code>hello.hello</code> is read-only (since we marked it <code>read_only: true</code> in ABI), so it executed it as a read-only call and immediately returned the result without creating a transaction. The output shows the return value. If this were a state-changing call, CLI would instead show a “Calling ... submitted transaction” message.
    </p>
    <p>
        To illustrate a state-changing example, suppose we had a token contract with a <code>transfer</code> function. After ABI registration (e.g., alias "koin"), you could do:
    </p>
<pre><code class="language-bash">> koin.transfer &lt;from_addr&gt; &lt;to_addr&gt; &lt;value&gt;
Calling koin.transfer with arguments 'from:"&lt;addr1&gt;" to:"&lt;addr2&gt;" value:100000000'
Submitted transaction with id 0x1220efc0...
</code></pre>
    <p>
        The CLI would wait for the transaction to be mined, or you can query the effect (like checking balances). In the snippet above, a subsequent <code>koin.balance_of &lt;addr2&gt;</code> returned the updated balance.
    </p>

    <h3>Interacting via Kondor (Wallet Integration)</h3>
    <p>
        While the CLI is great for testing and development, end-users will typically interact with contracts through a web interface or wallet. Kondor is the main wallet for Koinos. It allows users to:
    </p>
    <ul>
        <li>Manage addresses and keys.</li>
        <li>See token balances and NFTs.</li>
        <li>Sign transactions for contract calls initiated by web apps (similar to MetaMask’s function for Ethereum dApps).</li>
    </ul>
    <p>
        If you build a web DApp that uses your Koinos contract, you can use the Koilib JavaScript library to integrate with Kondor. Koilib can connect to Kondor by using Kondor’s injected provider. For example, Koilib can create a <code>Provider</code> that connects to a node (e.g., public RPC) and a <code>Signer</code> that uses Kondor’s signing capability.
    </p>
    <p>Basic flow for a web app:</p>
    <ul>
        <li>The user installs Kondor and unlocks it.</li>
        <li>Your web app (JS) detects Kondor (e.g., <code>window.kondor</code> might be present).</li>
        <li>Using Koilib, you can do:</li>
    </ul>
<pre><code class="language-javascript">import { Provider, Signer, Contract } from 'koilib';

const provider = new Provider([ "https://api.koinos.io" ]);  // RPC node

// Signer to use Kondor:
const signer = Signer.fromKondor(); // (this is conceptual; Koilib docs detail how to tie into Kondor's API)
signer.provider = provider;

const contract = new Contract({
  id: "19yp497RPiuWwsNUWp9cHWfbWUupHsRQLE", // contract address
  abi: helloABI,  // JSON ABI for the contract
  provider, signer
});

const { result } = await contract.functions.hello({ name: "Koinos" });
console.log(result.greeting); // Should output "Hello, Koinos!"
</code></pre>
    <ul>
        <li>When a state-changing function is called via <code>contract.functions.xxx</code>, Koilib will craft a transaction and ask Kondor to sign it (the user will see a prompt to approve the transaction). For read-only calls, Koilib will just execute a local call (no approval needed).</li>
        <li>Kondor, upon user approval, signs the transaction and optionally broadcasts it (Koilib can also handle the broadcast to the node).</li>
        <li>The app can then wait for the transaction to be mined and update UI accordingly.</li>
    </ul>
    <p>
        Kondor essentially acts as the key store and signer. It uses Koilib under the hood as well (the Kondor extension itself runs on Koilib). For more complex integrations, developers can refer to Kondor’s documentation or Koilib’s guide on using browser extensions.
    </p>

    <h3>Upgrading and Versioning Contracts</h3>
    <p>
        If you need to upgrade your contract, the process is simply to compile the new version to WASM and use the CLI (or Koilib) to upload it again with the same account (address). The upload command will replace the code at that address (only allowed if you control the address). The state data (stored in the contract’s object space) remains intact across upgrades, which is extremely powerful – you can deploy a fix without losing stored data, essentially performing what would be a “migration” in other blockchains seamlessly. The ABI may need updating if you changed function signatures or added/removed entry points – you’d distribute the new ABI to users/clients (and update any ABI registrations in CLI or config files).
    </p>
    <p>
        You should also bump version numbers within your own code for clarity, and possibly emit an event on upgrade so off-chain services know a new version is live.
    </p>
    <p>
        If a contract is meant to be immutable (e.g., a governance or trust-critical contract with no owner control), consider implementing the Koinos Authority contract interface to refuse future uploads. There is an “Immutable” contract example in the Koinos docs showing how to do that by overriding the authorize system call so that any operation of type <code>UPLOAD_CONTRACT</code> is denied unless certain conditions are met (or denied unconditionally).
    </p>
    <p>
        System contracts upgrades are done via governance proposals as discussed – beyond the scope of this guide, but in essence a proposal transaction contains the new WASM and when approved by block producers, the network automatically replaces the old system contract with the new one, in a forkless manner.
    </p>

    <h3>Read/Write Flows and Error Handling</h3>
    <p>
        To solidify understanding, let’s describe typical read and write flows in a contract call and how errors are handled:
    </p>
    <ul>
        <li><strong>Read-Only Call Flow:</strong> A user (or dApp) calls a contract entry point marked as <code>read_only</code> in the ABI. Tools like CLI or Koilib recognize this and execute a local query: the node will run the contract’s code in a sandbox without creating a transaction. The contract can read its state and return a result, but any attempted state modifications are ignored or cause an error. Because no blockchain state changes, no Mana is consumed for read-only calls. For example, querying an ERC20-style balance (<code>balance_of</code>) is read-only; CLI returns the balance immediately.</li>
        <li><strong>State-Changing Call Flow:</strong> A user calls a non-read-only entry point (e.g., <code>transfer</code>). This requires a transaction. The steps are: form the transaction with the contract address, entry point ID, and encoded argument data; sign it with the user’s key (or payer’s key); broadcast to network; miners execute the contract code as part of block production, and if <code>System.exit(0, result)</code> is called, the transaction is successful (state changes are applied), otherwise it’s reverted. The user spends Mana equal to the resources consumed (and possibly payer’s Mana if one is set). In our CLI token transfer example, after submission, we waited and then checked the updated balance to confirm the state change.</li>
        <li><strong>Error Handling:</strong> Within contract code, error conditions should result in a nonzero exit code to signal failure. For instance, if our Calculator contract’s <code>div</code> function is called with <code>y = 0</code>, we want to abort. In AssemblyScript, we could do:</li>
    </ul>
<pre><code class="language-typescript">if (args.y == 0) {
  System.exit(1); // exit with error code 1 (generic failure)
}
</code></pre>
    <p>
        When <code>System.exit(1)</code> is called, the contract execution stops immediately and the state changes (if any were made before the exit) are rolled back – effectively the whole operation is reverted. The caller will get an error (the CLI might show "error: returned non-zero exit code" or similar). We can use different exit codes if we want to represent different error types, but usually 1 is enough to indicate a failure (the specific code isn’t widely used by client apps except as nonzero = failure).
    </p>
    <p>
        Because Koinos doesn’t currently support returning rich error messages directly (there’s no native concept of revert strings like Ethereum), a common pattern is to return an error code or boolean in the result message. For example, a token <code>transfer_result</code> might have a <code>bool success</code> field, or an <code>error_code</code> field. However, if a contract returns an error result normally (<code>exit(0)</code> with an error code in the data), that doesn’t revert state – it’s like an application-level error. Use <code>System.exit( )</code> with nonzero to truly revert. It’s up to the contract developer to choose which approach in each situation. The Authority and Immutable examples in the official docs show usage of <code>System.exit</code> for controlling logic flow.
    </p>

    <h3>Using System Contracts (as a developer)</h3>
    <p>
        One additional aspect: as a contract developer on Koinos, you might sometimes call into system contracts or utilize their functionality. For example, instead of writing your own token contract from scratch, you might choose to import the Koinos Tokens standard (KRC) system contract API. Koinos system contracts (like the Koinos standard token contract, NFT contract, etc.) expose entry points themselves that you can invoke from your contract via an inter-contract call (using a system call to call another contract’s entry point). The details of inter-contract calls involve packing arguments and using <code>System.callContract</code> or similar. While that’s beyond this intro, be aware that everything is a contract includes the possibility that your contract can call system-level services (like checking an account’s Mana, invoking the KOIN token’s transfer on behalf of a user, etc.) if it has the privilege or proper authorization to do so.
    </p>

    <h2>Example: Putting It All Together</h2>
    <p>
        Let’s walk through a quick practical example combining many of the above steps, using the AssemblyScript SDK as it’s most accessible:
    </p>
    <p>Suppose we want to create a simple Counter contract. It has two entry points:</p>
    <ul>
        <li><code>increment</code>: increments an internal counter by a given amount (or by 1 if no amount given) and returns the new value.</li>
        <li><code>get_count</code>: a read-only call that returns the current counter value.</li>
    </ul>
    <ol>
        <li><strong>Define Proto (<code>counter.proto</code>):</strong></li>
<pre><code class="language-protobuf">syntax = "proto3";
package myapp.counter;

message increment_arguments { uint32 amount = 1; }
message increment_result { uint32 new_value = 1; }

message get_count_arguments {}        // no fields, just an empty message
message get_count_result { uint32 value = 1; }
</code></pre>
        <li><strong>Generate types and boilerplate:</strong></li>
<pre><code class="language-bash">koinos-sdk-as-cli generate-contract-proto   # generates assembly/proto and types
koinos-sdk-as-cli generate-contract-as counter.proto
</code></pre>
    <p>This creates <code>assembly/Counter.boilerplate.ts</code> and <code>assembly/index.ts</code> with a structure.</p>
        <li><strong>Implement logic (<code>Counter.ts</code>):</strong></li>
<pre><code class="language-typescript">import { System, Protobuf, Uint64 } from "@koinos/sdk-as";
import { counter as ProtoNS } from "./proto/counter";

const COUNTER_SPACE_ID = 0;  // using store id 0 for our counter
const COUNTER_KEY = new Uint8Array(0); // using empty key (could also pick a specific bytes key)

export class Counter {
  // Helper to load current count from storage
  private loadCounter(): u32 {
    const space = new System.ObjectSpace(false, System.getContractId(), COUNTER_SPACE_ID);
    const valueBytes = System.getBytes(space, COUNTER_KEY);
    if (valueBytes !== null && valueBytes.length > 0) {
      // decode uint32 from bytes (assuming little-endian encoding of u32)
      return Protobuf.decode&lt;Uint64&gt;(valueBytes, Uint64.decode).toUint32();
      // Note: using Uint64 from sdk-as as a container to decode 64-bit, since proto3 doesn't have unsigned 32 directly
    }
    return 0;
  }

  // Helper to save current count to storage
  private saveCounter(value: u32): void {
    const space = new System.ObjectSpace(false, System.getContractId(), COUNTER_SPACE_ID);
    const uint64Val = new Uint64(value); // wrap u32 in Uint64 for encoding
    System.putBytes(space, COUNTER_KEY, Protobuf.encode(uint64Val, Uint64.encode));
  }

  increment(args: ProtoNS.increment_arguments): ProtoNS.increment_result {
    const incrementBy = args.amount || 1;
    const current = this.loadCounter();
    const updated = current + incrementBy;
    this.saveCounter(updated);
    const res = new ProtoNS.increment_result();
    res.new_value = updated;
    return res;
  }

  get_count(args: ProtoNS.get_count_arguments): ProtoNS.get_count_result {
    const res = new ProtoNS.get_count_result();
    res.value = this.loadCounter();
    return res;
  }
}
</code></pre>
    <p>This contract uses the contract’s own storage to keep a counter (starting at 0 if not present). We used <code>System.getBytes</code> and <code>System.putBytes</code> for state (with an <code>ObjectSpace</code> identified by the contract’s address and an ID). We used <code>Uint64</code> from the SDK because the Protobuf encoding functions available expect a type; since proto3 <code>uint32</code> would be represented as a Varint, we leveraged the <code>Uint64</code> type to decode/encode it (setting a 32-bit value is fine as it will just be a smaller varint). This is a bit of a low-level detail; in a future SDK version they might include a convenience for unsigned 32.</p>
        <li><strong>Compile the contract:</strong></li>
<pre><code class="language-bash">koinos-sdk-as-cli build-all release counter.proto
</code></pre>
    <p>This yields <code>contract.wasm</code> and <code>counter.abi</code>. The ABI will have methods <code>increment</code> (not read-only) and <code>get_count</code> (<code>read_only = true</code>).</p>
        <li><strong>Deploy the contract (CLI):</strong></li>
<pre><code class="language-bash">> open wallet.counter.purse mypass
Opened wallet: wallet.counter.purse
> connect http://api.koinos.io
Connected to endpoint http://api.koinos.io
> upload build/release/contract.wasm
Contract uploaded with address 1PMyCounterAddr...  (just an example)
Transaction with ID 0x1234... submitted.
Mana cost: X (Disk: Y, Network: Z, Compute: W)
</code></pre>
    <p>Now our counter is on-chain at address <code>1PMyCounterAddr...</code>.</p>
        <li><strong>Register ABI and interact:</strong></li>
<pre><code class="language-bash">> register counter 1PMyCounterAddr... abi/counter.abi
Contract 'counter' at address 1PMyCounterAddr... registered

> list
counter.get_count   - Returns the current counter value
counter.increment   - Increments the counter by an amount

> counter.get_count
value:0   # initial value is 0

> counter.increment 5
Calling counter.increment with arguments 'amount:5'
Transaction with ID 0xabc... submitted.
# (Wait a bit for transaction to be mined, CLI might not show result for state-changing call)
> counter.get_count
value:5

> counter.increment   # no argument means default (0 in args, which we treat as 1)
Calling counter.increment with arguments ''
Transaction with ID 0xdef... submitted.

> counter.get_count
value:6
</code></pre>
    <p>As seen:</p>
    <ul>
        <li><code>get_count</code> returned 0 initially.</li>
        <li>After <code>increment 5</code>, a transaction was made. The CLI does not directly output the return value of state-changing calls (unless you specifically fetch the transaction receipt). We then manually check <code>get_count</code> and see it became 5.</li>
        <li>Then <code>increment</code> with no parameter used the default of 1, and the counter became 6.</li>
    </ul>
    <p>This demonstrates a simple read/write flow: read-only queries and state-changing updates.</p>
    <p><strong>Error handling example:</strong> If our contract had a constraint (say it shouldn’t exceed some max value), we could add:</p>
<pre><code class="language-typescript">if (updated > MAX_VALUE) {
  System.exit(1);  // abort if limit exceeded
}
</code></pre>
    <p>in the <code>increment</code> method. Then calls that break the rule would revert the state (counter remains unchanged). The CLI would report an error on that call, likely “RPC error: non-zero exit code” or similar.</p>
    <p>By following this end-to-end example, you’ve seen how to create, deploy, and use a Koinos smart contract.</p>

    <h2>System Contracts and Governance</h2>
    <p>
        Before concluding, it’s worth briefly identifying some key system contracts on Koinos and how they relate to your development:
    </p>
    <ul>
        <li><strong>KOIN Token Contract:</strong> Implements the native token (KOIN) with standard methods like <code>transfer</code>, <code>balance_of</code>, etc., following the Koinos token standard (KRC-20 analogous). This is deployed at a well-known address (which the CLI may pre-register via config). When you transfer KOIN through CLI or wallets, you’re actually invoking this contract.</li>
        <li><strong>Resource & Mana Management:</strong> There’s a system contract (or system calls) managing Mana regeneration and resource limits. This isn’t something you call directly, but it enforces the Mana model described earlier.</li>
        <li><strong>Governance Contract:</strong> Handles on-chain proposals and voting by block producers. This contract receives proposal transactions (which contain changes like new system contract WASMs or parameter tweaks) and coordinates the voting phases (review, voting, application). If you’re running a node or a block producer, you might interact with this via special transactions, but as a dApp developer, you typically won’t touch it.</li>
        <li><strong>Nameservice and Other Utilities:</strong> Koinos may have system contracts for account name resolution, etc. Not yet as prominent, but likely to come.</li>
        <li><strong>NFT and Other Standards:</strong> The Koinos team and community have system or standard contracts for NFTs (non-fungible tokens, KRC-721 standard), governance tokens, staking contracts, etc. These can often serve as templates for your own contracts or you can interact with them (e.g., your game contract might call the NFT contract to mint an item).</li>
    </ul>
    <p>
        Because system contracts are upgradeable by governance, always ensure you’re aware of current interface versions (the ABI) when interacting with them. The Koinos documentation and GitHub koinos-contracts-as or koinos-contracts-cpp repositories provide source code for these system contracts for reference.
    </p>

    <h2>Glossary of Koinos Terms</h2>
    <p><strong>Koinos (KOIN):</strong> The native coin of the Koinos blockchain. Holding KOIN gives you Mana and governance power. KOIN itself is implemented as a smart contract (the KOIN token contract).</p>
    <p><strong>Mana:</strong> A resource derived from KOIN that is consumed to execute transactions instead of paying fees. Mana regenerates over time (20% per day). If you have X KOIN fully charged, you have X Mana. Using Mana does not destroy KOIN; it temporarily “locks” a proportional amount of KOIN until regenerated.</p>
    <p><strong>Resource Credits (RC):</strong> In Koinos, often refers to the granular accounting of resources (compute, disk, network) that Mana covers. RC limits can be set to restrict how much of your Mana someone else can use when you sponsor them. Essentially, RC is a technical detail; Mana is the user-facing concept.</p>
    <p><strong>Smart Contract:</strong> A WebAssembly module deployed to a Koinos address that can be invoked by transactions or other contracts. Koinos smart contracts are upgradeable and can be written in multiple languages (AssemblyScript, C++, etc.).</p>
    <p><strong>AssemblyScript (AS) SDK:</strong> The toolkit for writing Koinos contracts in AssemblyScript (TypeScript). Provides convenient libraries (<code>System</code>, <code>Protobuf</code>, etc.) for interacting with Koinos APIs. Most high-level examples use this.</p>
    <p><strong>C++ SDK:</strong> The toolkit for writing Koinos contracts in C++. Allows low-level control and direct use of system calls. Requires WebAssembly-targeted compilation (WASI). Was the first SDK; core system contracts are written in C++.</p>
    <p><strong>WASM (WebAssembly):</strong> The binary format in which Koinos contracts are compiled. The Koinos VM executes WASM code. Any language that can compile to WASM could be used if an SDK or bindings exist.</p>
    <p><strong>Entry Point:</strong> A function entry in a smart contract that can be called externally. Represented by a 32-bit identifier on-chain. The ABI maps a human-readable name to this ID. For example, “transfer” might correspond to <code>0x62efa292</code>. The contract’s dispatch logic uses the entry point to invoke the correct function.</p>
    <p><strong>ABI (Application Binary Interface):</strong> A JSON (or binary) file that describes a contract’s entry points (methods), their argument and return types (by referencing Protobuf message types), and other metadata. Clients use the ABI to encode arguments and decode results correctly. The ABI is generated from the <code>.proto</code> definitions and is essential for interacting with contracts via CLI, wallet, or library.</p>
    <p><strong>Protobuf (Protocol Buffers):</strong> A serialization format used to define the structure of data exchanged with contracts. Koinos uses Protobuf messages for contract inputs/outputs, which ensures type-safe encoding/decoding across different languages. Developers write <code>.proto</code> files to define their contract’s interface, and the SDKs handle the rest.</p>
    <p><strong>System Call:</strong> A function provided by the blockchain for contracts to use for core operations (reading args, accessing state, calling other contracts, etc.). These are analogous to an operating system’s system calls. In code, <code>System.getArguments</code>, <code>System.putBytes</code>, <code>System.exit</code>, etc., are wrappers around actual system calls. Each system call has an ID and is implemented either in the blockchain microservices or in system contracts. For instance, storing data actually involves a system call that interfaces with the chain’s state database.</p>
    <p><strong>Object Space:</strong> A namespace for contract storage. It’s defined by a triple (system flag, zone, id). For user contracts, <code>system=false</code>, <code>zone</code> is the contract’s address, and <code>id</code> is a developer-chosen number to allow multiple distinct sub-stores. In our counter example, we used <code>id = 0</code> as a default space. Keys and values stored are byte arrays. The object space prevents contracts from interfering with each other’s data.</p>
    <p><strong>System Contract:</strong> A smart contract with elevated privileges (can access <code>system=true</code> spaces, meaning global state). System contracts implement core blockchain logic (consensus, governance, token). They can only be upgraded via governance proposals (except in testnet or development where a manual upload might be possible by consensus override).</p>
    <p><strong>User Contract:</strong> Any contract deployed by an end-user or developer to implement custom logic (dApps, tokens, etc.). Lives in user space, cannot directly alter global state or parameters. Upgradeable by the address owner.</p>
    <p><strong>Governance (Decentralized Governance):</strong> The on-chain process by which Koinos stakeholders (block producers) propose and vote on upgrades or changes. A successful governance proposal might upgrade a system contract or change a parameter (like block size, etc.). Governance ensures Koinos can evolve without hard forks, as long as consensus of validators is achieved on-chain.</p>
    <p><strong>Koinos CLI:</strong> A command-line interface tool to interact with the Koinos blockchain. Allows wallet management, token transfers, contract uploads, and contract calls in an interactive shell. It’s a crucial developer tool for testing and deploying contracts.</p>
    <p><strong>Koilib:</strong> A JavaScript library for Koinos that simplifies building web or Node.js applications. It can create and sign transactions, call contract functions (including waiting for confirmations), and integrate with wallets like Kondor. Essentially, Koilib is to Koinos what web3.js or ethers.js is to Ethereum.</p>
    <p><strong>Kondor:</strong> A browser extension wallet for Koinos. Manages keys and identities, and injects a provider into web pages for dApps to interact with. Kondor allows users to approve or reject transactions requested by dApps, providing security. It’s analogous to MetaMask for Ethereum. Kondor uses Koilib internally and supports the latest Koinos features.</p>
    <p><strong>Harbinger Testnet:</strong> The public test network for Koinos where developers can deploy and test contracts with test KOIN (tKOIN) without risking real funds. It mirrors mainnet behavior but typically runs newer, sometimes experimental versions of system contracts to “harbinger” what comes to mainnet. Use a faucet to get tKOIN, and use the testnet API endpoints or KoinosBlocks explorer for Harbinger.</p>
    <p><strong>Mainnet:</strong> The live Koinos network where real KOIN is used. Contracts deployed here are live for end-users. Always double-check addresses and be cautious when upgrading contracts on mainnet due to the irreversible consequences.</p>

    <p>
        With this comprehensive knowledge, you are now equipped to develop, deploy, and manage smart contracts on Koinos. The feeless Mana model, upgradeability, and familiar development process (especially using AssemblyScript) make Koinos an exciting platform for decentralized applications. Happy coding on Koinos!
    </p>
<h1>Koinos Contract Standards (KCS)</h1>

<section id="kcs-1">
    <h2>KCS 1: Token Standard</h2>
    <p><strong class="status">Status:</strong> Final</p>
    <p class="authors"><strong>Authors:</strong> Koinos Group (<a href="https://github.com/koinos" target="_blank" rel="noopener noreferrer">https://github.com/koinos</a>), Julián González (<a href="https://github.com/joticajulian" target="_blank" rel="noopener noreferrer">https://github.com/joticajulian</a>)</p>

    <p>A contract standard for tokens on the Koinos blockchain.</p>

    <h3>Long Description</h3>
    <p>This standard is to define how tokens can work on the Koinos blockchain.</p>
    <p>Tokens using this standard may include additional utility and functionality beyond this standard in their smart contract logic. This document defines the base functionality in order to adhere to KCS-1 standard.</p>

    <h3>Why</h3>
    <p>This is the first standard for token contracts on the Koinos blockchain. The most representative examples are KOIN and VHP contracts. Every smart contract platform requires fungible tokens at a bare minimum which allows users to to utilize the decentralized ledger and trade value amongst themselves.</p>

    <h3>Specification</h3>
    <p>At a minimum, a token contract using this standard will include the following methods and unique data:</p>

    <h4>Read methods</h4>

    <h5>name</h5>
    <p>Returns the name of the token. No arguments required.</p>
    <p>Protobuf definition</p>
    <pre><code class="language-protobuf">
// Arguments
message name_arguments {}

// Result
message name_result {
    string value = 1;
}
    </code></pre>

    <h5>symbol</h5>
    <p>Returns the symbol for the token. No arguments required.</p>
    <p>Protobuf definition</p>
    <pre><code class="language-protobuf">
// Arguments
message symbol_arguments {}

// Results
message symbol_result {
    string value = 1;
}
    </code></pre>

    <h5>decimals</h5>
    <p>Returns the decimal precision of the token. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message decimals_arguments {}

// Result
message decimals_result {
    uint32 value = 1;
}
    </code></pre>

    <h5>total_supply</h5>
    <p>Returns the total supply of the token. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message total_supply_arguments {}


// Result
message total_supply_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>balance_of</h5>
    <p>Returns how many tokens a specific address holds.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message balance_of_arguments {
    bytes owner = 1 [(btype) = ADDRESS];
}

// Result
message balance_of_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h4>Write methods</h4>

    <h5>mint</h5>
    <p>Used by the contract owner to initially mint the token to a given address.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message mint_arguments {
    bytes to = 1 [(btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
}

// Result
message mint_result {}
    </code></pre>
    <p>The method should emit a <code>mint_event</code> upon success. The event should indicate the recipient of the mint as an impacted account.</p>
    <pre><code class="language-protobuf">
// Event
message mint_event {
    bytes to = 1 [(btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
}
    </code></pre>

    <h5>transfer</h5>
    <p>This will transfer tokens to a new owner. The authorization is checked with the native <code>check_authority</code> system call. It is also authorized if the contract of <code>from</code> is the one that called the token contract.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message transfer_arguments {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    bytes to = 2 [(koinos.btype) = ADDRESS];
    uint64 value = 3 [jstype = JS_STRING];
}

// Result
message transfer_result {}
    </code></pre>
    <p>The transfer event should emit a <code>transfer_event</code> upon success. The event should indicate the receiver and then the sender as impacted accounts.</p>
    <pre><code class="language-protobuf">
// Event
message transfer_event {
    bytes from = 1 [(btype) = ADDRESS];
    bytes to = 2 [(btype) = ADDRESS];
    uint64 value = 3 [jstype = JS_STRING];
}
    </code></pre>

    <h5>burn (optional)</h5>
    <p>Burns an amount of token from an address. The authorization is checked with the native <code>check_authority</code> system call. It is also authorized if the contract of <code>from</code> is the one that called the token contract.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message burn_arguments {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
}

// Result
message burn_result {}
    </code></pre>
    <p>The method should emit a <code>burn_event</code> upon success. The event should indicate the source as an impacted account.</p>
    <pre><code class="language-protobuf">
// Event
message burn_event {
    bytes from = 1 [(btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
}
    </code></pre>

    <h3>Computation of entry points</h3>
    <p>On the Koinos blockchain, each contract function has an <em>entry point</em> associated which should be referenced inside the transaction when interacting with the contract. This <em>entry point</em> is used to identify the function, not the name of the function.</p>
    <p>The current standard uses the following process to define the entry point:</p>
    <ol>
        <li>Compute the sha256 of the name function.</li>
        <li>Take the first 4 bytes of the hash.</li>
        <li>Convert these bytes into a number.</li>
    </ol>
    <p>For instance, the sha256 of <code>transfer</code> is <code>27f576cafbb263ed44be8bd094f66114da26877706f96c4c31d5a97ffebf2e29</code>. Then the <em>entry point</em> for this function is defined as 0x27f576ca</p>

    <h3>Expected Unique Data and Types</h3>
    <p>With the proposed implementation developers would set the following constants before uploading their token contract:</p>
    <ul>
        <li><code>NAME</code> - a string for the human readable name of the token.</li>
        <li><code>SYMBOL</code> - a string for the symbol or ticker used for the token (all uppercase).</li>
        <li><code>DECIMALS</code> - a u32 for the decimal precision of the token.</li>
    </ul>

    <h3>Check authority system call</h3>
    <p>The koinos framework comes with an innovative system for authorizations, where users can upload personal contracts that will be called to resolve authorizations. In order to take advantage of this feature, the token contract should call the <code>check_authority</code> system call. And it works in this way:</p>
    <ol>
        <li>If the user has a smart contract, and he has configured it with an <code>authorize</code> function, then this smart contract will be called to resolve the authority.</li>
        <li>If the user doesn't have a smart contract, then the blockchain will search if the user signed the transaction and in that case approve the authorization.</li>
    </ol>
    <p>This is a flow chart of the system call:</p>
    <pre><code class="language-mermaid">
flowchart TD
    ini[TOKEN CONTRACT\nTransfer from Alice to Bob] -->|Does Alice authorize\n this operation?| A
    A[check_authority\nsystem call] --> B
    B{Has Alice a\n contract for\n authorizations?} -->|YES\nDo you authorize\nthis operation?| C
    C["Call Alice's contract"] -->|true/false| D
    B --> |NO| E
    E{Transaction signed\nby Alice?} --> |YES\ntrue|D
    E --> |NO\nfalse|D[Return response to\n TOKEN CONTRACT]
    </code></pre>

    <h3>Implementation</h3>
    <p>There are some implementations of this token contract.</p>
    <ul>
        <li><a href="https://github.com/roaminro/koinos-sdk-as-examples/blob/4e68844d41a53bcf1f5a43056d9a638b544d816c/token/assembly/Token.ts" target="_blank" rel="noopener noreferrer">Token contract</a></li>
        <li><a href="https://github.com/koinos/koinos-contracts-cpp/blob/80f55538a5fbf6526e2e1df93d9bf4981eb6c2e7/contracts/koin/koin.cpp" target="_blank" rel="noopener noreferrer">KOIN token</a> (written in C++)</li>
        <li><a href="https://github.com/koinos/koinos-contracts-as/blob/213277bc9c54dd049d7797a657dac890e8207560/contracts/vhp/assembly/Vhp.ts" target="_blank" rel="noopener noreferrer">VHP Token</a></li>
    </ul>

    <h3>References</h3>
    <ul>
        <li><a href="https://www.youtube.com/watch?v=lDsAQ7y9XTw" target="_blank" rel="noopener noreferrer">Koinos authority system explained by Michael Vandeberg (video)</a> </li>
    </ul>
</section>

<section id="kcs-2">
    <h2>KCS 2: NFT Collection Standard</h2>
    <p><strong class="status">Status:</strong> Final</p>
    <p class="authors"><strong>Authors:</strong> Ederlang (<a href="https://github.com/ederaleng" target="_blank" rel="noopener noreferrer">https://github.com/ederaleng</a>), Von Looten (<a href="https://github.com/vonlooten" target="_blank" rel="noopener noreferrer">https://github.com/vonlooten</a>), Justin W (<a href="https://github.com/jredbeard" target="_blank" rel="noopener noreferrer">https://github.com/jredbeard</a>), Dokterkraakbeen (<a href="https://github.com/Dokterkraakbeen" target="_blank" rel="noopener noreferrer">https://github.com/Dokterkraakbeen</a>)</p>

    <p>A token contract standard for NFT collections on the Koinos blockchain.</p>

    <h3>Long Description</h3>
    <p>This standard is to define how NFT collections can work on the Koinos blockchain. The functionality is setup to closely mimic the <a href="https://eips.ethereum.org/EIPS/eip-721" target="_blank" rel="noopener noreferrer">ERC-721</a> standard on Ethereum. We believe that NFTs on Ethereum have become a common standard and our goal is to provide similar functionality here for users and developers who have come to expect this basic layer of functionality.</p>
    <p>NFTs using this standard may include additional utility and functionality beyond this standard. This is just the base layer of functionality that is expected.</p>

    <h3>Why</h3>
    <p>By mimicking the Ethereum NFT collection standard this makes it easy to onboard NFT projects who may have already launched collections on other chains. Many tools and resources already available for working with NFT collections will already be compatible here and easy to implement on Koinos.</p>
    <p>Further, by setting forth a standard for NFT collections developers can be sure that NFT marketplaces (including <a href="https://kollection.app" target="_blank" rel="noopener noreferrer">Kollection</a>) will be able to aggregate and display these NFT collections.</p>

    <h3>Why the concept of "owner"?</h3>
    <p>On Koinos contracts can be either upgradeable or immutable. A contract address is also a standard wallet address. This default behavior on Koinos is different than Ethereum and ERC-721 contracts.</p>
    <p>By default, the wallet that can make changes to a contract is the address that uploaded the contract. If a contract is set to immutable (by blocking authorities) then the wallet used to upload the contract can no longer make changes. In our implementation of KCS-2 there is the concept of an "owner" address and the ability to transfer that ownership. That means that a collection owner could transfer the ownership of the collection to another individual or organization even if the contract is set to be immutable. Even though this is "unnecessary" to be default behavior on Koinos because standard wallet addresses can be contract addresses it's useful to understand why the concept of <code>owner</code> is used here.</p>
    <p>In addition to having the ability to transfer ownership, having an <code>owner</code> means that front-ends can verify the collection owner in order to set certain things like off-chain metadata for a collection (YouTube link, Discord, etc).</p>

    <h3>Specification</h3>
    <p>At a minimum, an NFT contract using this standard will include the following methods and unique data:</p>

    <h4>Read methods</h4>

    <h5>name</h5>
    <p>Returns the name of the NFT. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message name_arguments {}
// Result
message name_result {
    string value = 1;
}
    </code></pre>

    <h5>symbol</h5>
    <p>Returns the symbol for the NFT. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message symbol_arguments {}
// Result
message symbol_result {
    string value = 1;
}
    </code></pre>

    <h5>uri</h5>
    <p>A universal resource identifier that is a link to metadata formatted in <code>JSON</code> for individual items within the collection (each NFT). This is usually an <code>https</code> or <code>ipfs</code> link. The URI is the base path and the individual metadata contained is at <code>/&lt;item number&gt;</code>. As an example, if <code>https://somekoinosexample.com/mycollection</code> were the URI, and the first token is the hex string representation of '1', then the 1st item's metadata would be located at <code>https://somekoinosexample.com/mycollection/0x31</code> and the 2nd would be at <code>/0x32</code> and so forth.</p>
    <p>This is one area where the implementation differs slightly from ERC-721. With ERC-721 a URI is set per-token, here it is set for the whole collection and the full path for a token's metadata is assumed based on the constructed path.</p>
    <p>The metadata should include at a minimum a name, description, and a URI where the associated image can be found. Other properties are arbitrary and can be any properties you deem fit for your collection. Attributes are also optional but will often be used.</p>
    <p>The JSON located at these URI's should follow this format (similar and compatible with ERC-721 format):</p>
    <pre><code class="language-json">
{
    "name":"Collection Nft #1",
    "description":"The first of this collection",
    "attributes":[
       {
          "trait_type":"Awesome",
          "value":"Yes"
       },
       {
          "trait_type":"Likes Standards",
          "value":"Loves Them"
       }
    ],
    "my_arbitrary_custom_property": "totally ok!",
    "image":"https://somekoinosexample.com/mycollection/images/0.png"
}
    </code></pre>
    <p>Returns the endpoint to resolve the metadata.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message uri_arguments {}
// Result
message uri_result {
    string value = 1;
}
    </code></pre>

    <h5>owner</h5>
    <p>Returns the owner of the collection.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message owner_arguments {}
// Result
message owner_result {
    bytes value = 1 [(koinos.btype) = ADDRESS];
}
    </code></pre>

    <h5>total_supply</h5>
    <p>Returns the total supply of the NFT collection.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message total_supply_arguments {}
// Result
message total_supply_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>royalties</h5>
    <p>Returns the royalties configuration.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
message royalty {
    uint64 percentage = 1 [jstype = JS_STRING];
    bytes address = 2 [(koinos.btype) = ADDRESS];
}
// Arguments
message royalties_arguments {}
// Result
message royalties_result {
    repeated royalty value = 1;
}
    </code></pre>

    <h5>balance_of</h5>
    <p>Returns how many NFTs a specific address holds.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message balance_of_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
}
// Result
message balance_of_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>owner_of</h5>
    <p>Returns the owner of a specific NFT.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message owner_of_arguments {
    bytes token_id = 1 [(koinos.btype) = HEX];
}
// Result
message owner_of_result {
    bytes value = 1 [(koinos.btype) = ADDRESS];
}
    </code></pre>

    <h5>get_approved</h5>
    <p>Returns the account allowed to operate a specific NFT (apart from the owner).</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message get_approved_arguments {
    bytes token_id = 1 [(koinos.btype) = HEX];
}
// Result
message get_approved_result {
    bytes value = 1 [(koinos.btype) = ADDRESS];
}
    </code></pre>

    <h5>is_approved_for_all</h5>
    <p>Returns if an account is authorized to operate all NFTs of a specific owner.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message is_approved_for_all_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes operator = 2 [(koinos.btype) = ADDRESS];
}
// Return
message is_approved_for_all_result {
    bool value = 1;
}
    </code></pre>

    <h4>Write methods</h4>

    <h5>transfer_ownership</h5>
    <p>Function to transfer the ownership of the collection to other account. Only the owner of the collection can perform this operation.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message transfer_ownership_arguments {
    bytes value = 1 [(koinos.btype) = ADDRESS];
}
// Result
message transfer_ownership_result {}
    </code></pre>
    <p>The method should emit <code>owner_event</code> upon success with the name <code>collections.owner_event</code>. The event should indicate the new owner and then the previous owner as impacted accounts.</p>
    <pre><code class="language-protobuf">
// Event
message owner_event {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    bytes to = 2 [(koinos.btype) = ADDRESS];
}
    </code></pre>

    <h5>set_royalties</h5>
    <p>Function to set the royalties. Only the owner of the collection can perform this operation.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
message royalty {
    uint64 percentage = 1 [jstype = JS_STRING];
    bytes address = 2 [(koinos.btype) = ADDRESS];
}

// Arguments
message set_royalties_argument {
    repeated royalty value = 1;
}
// Result
message set_royalties_result {}
    </code></pre>
    <p>The method should emit <code>royalties_event</code> upon success with the name <code>collections.royalties_event</code>. The event should indicate the addresses of the royalties as impacted accounts.</p>
    <pre><code class="language-protobuf">
message royalty {
    uint64 percentage = 1 [jstype = JS_STRING];
    bytes address = 2 [(koinos.btype) = ADDRESS];
}

// Event
message royalties_event {
    repeated royalty value = 1;
}
    </code></pre>

    <h5>approve</h5>
    <p>Grant permissions to other account to manage the NFTs owned by the user.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message approve_arguments {
    bytes approver_address = 1 [(koinos.btype) = ADDRESS];
    bytes to = 2 [(koinos.btype) = ADDRESS];
    bytes token_id = 3 [(koinos.btype) = HEX];
}
// Result
message approve_result {}
    </code></pre>
    <p>The method should emit <code>token_approval_event</code> upon success with the name <code>collections.token_approval_event</code>. The event should indicate the approved address and then the approver address as impacted accounts.</p>
    <pre><code class="language-protobuf">
// Event
message token_approval_event {
    bytes approver_address = 1 [(koinos.btype) = ADDRESS];
    bytes to = 2 [(koinos.btype) = ADDRESS];
    bytes token_id = 3 [(koinos.btype) = HEX];
}
    </code></pre>

    <h5>set_approval_for_all</h5>
    <p>Grant permissions to other account to manage all Tokens owned by the user.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message set_approval_for_all_arguments {
    bytes approver_address = 1 [(koinos.btype) = ADDRESS];
    bytes operator_address = 2 [(koinos.btype) = ADDRESS];
    bool approved = 3;
}
// Result
message set_approval_for_all_result {}
    </code></pre>
    <p>The method should emit <code>operator_approval_event</code> upon success with the name <code>collections.operator_approval_event</code>. The event should indicate the operator address and then the approver address as impacted accounts.</p>
    <pre><code class="language-protobuf">
// Event
message operator_approval_event {
    bytes approver_address = 1 [(koinos.btype) = ADDRESS];
    bytes operator_address = 2 [(koinos.btype) = ADDRESS];
    bool approved = 3;
}
    </code></pre>

    <h5>mint</h5>
    <p>Used by the contract owner to initially mint the NFT to a given address.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message mint_arguments {
    bytes to = 1 [(koinos.btype) = ADDRESS];
    bytes token_id = 2 [(koinos.btype) = HEX];
}
// Result
message mint_result {}
    </code></pre>
    <p>The method should emit <code>mint_event</code> upon success with the name <code>collections.mint_event</code>. The event should indicate the recipient of the mint as an impacted account.</p>
    <pre><code class="language-protobuf">
// Event
message mint_event {
    bytes to = 1 [(koinos.btype) = ADDRESS];
    bytes token_id = 2 [(koinos.btype) = HEX];
}
    </code></pre>

    <h5>transfer</h5>
    <p>This will transfer an NFT to a new owner. The authorization is checked using allowances and/or smart wallets as explained above.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message transfer_arguments {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    bytes to = 2 [(koinos.btype) = ADDRESS];
    bytes token_id = 3 [(koinos.btype) = HEX];
}
message transfer_result {}
    </code></pre>
    <p>The method should emit <code>transfer_event</code> upon success with the name <code>collections.transfer_event</code>. The event should indicate the receiver and then the sender as impacted accounts.</p>
    <pre><code class="language-protobuf">
// Event
message transfer_event {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    bytes to = 2 [(koinos.btype) = ADDRESS];
    bytes token_id = 3 [(koinos.btype) = HEX];
}
    </code></pre>

    <h5>burn (optional)</h5>
    <p>Burns an amount of NFT from an address. The authorization is checked using allowances and/or smart wallets as explained above.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message burn_arguments {
    bytes token_id = 1 [(koinos.btype) = HEX];
}
// Result
message burn_result {}
    </code></pre>
    <p>The method should emit <code>burn_event</code> upon success with the name <code>collections.burn_event</code>. The event should indicate the previous owner as an impacted account.</p>
    <pre><code class="language-protobuf">
// Event
message burn_event {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    bytes token_id = 2 [(koinos.btype) = HEX];
}
    </code></pre>

    <h3>Expected Unique Data and Types</h3>
    <p>With our proposed implementation you would set the following constants before uploading your contract:</p>
    <ul>
        <li><code>NAME</code> - a string for the human readable name of a collection</li>
        <li><code>SYMBOL</code> - a string for the symbol used for this collection (all uppercase)</li>
        <li><code>MINT_PRICE</code> - a u64 for the price to mint an NFT for a collection in satoshis (KOIN has a precision of 8)</li>
        <li><code>MINT_FEE</code> - a boolean (true/false). If set, addresses other than the owner can mint NFTs for the <code>MINT_PRICE</code></li>
        <li><code>MAX_SUPPLY</code> - this is the maximum amount of mintable tokens (NFTs) in your collection.</li>
        <li><code>URI</code> - a string that contains the metadata URI (can be ipfs or https)</li>
        <li><code>OWNER</code> - A Base58 decoded Unit8Array which is the address of the initial contract owner</li>
        <li><code>TOKEN_PAY</code> - this is the type of token accepted for minting. If using KOIN, for harbinger testnet, this would be <code>19JntSm8pSNETT9aHTwAUHC5RMoaSmgZPJ</code>. For mainnet, this would be <code>15DJN4a8SgrbGhhGksSBASiSYjGnMU8dGL</code>.</li>
        <li><code>ADDRESS_PAY</code> - this is the address that will receive the funds for minting.</li>
    </ul>

    <h4>Token ID's</h4>
    <p>The token ID is stored as a type <code>bytes</code> and is serialized as hex. On Ethereum with ERC-721, a token ID is of type <code>uint256</code> - this specific type is not available in protobuf so <code>bytes</code> is used instead because it can fit the same data that you could in a <code>uint256</code> to try to mimic this standard.</p>
    <p>Any hex will work, however, we recommend using hex string representation for token ID's. As an example, a string of <code>"1"</code> would be <code>0x31</code>. In the case of non-numerical token ID's, such as <a href="https://kap.domains/" target="_blank" rel="noopener noreferrer">KAP domains</a>, an example string of <code>"kollection.koin"</code> would be <code>0x6b6f6c6c656374696f6e2e6b6f696e</code>.</p>
    <p>The supplied example implementation contract will automatically mint in numerical order as hex strings.</p>
    <p>An example NodeJS implementation for encoding/decoding hex strings:</p>
    <pre><code class="language-javascript">
function encodeHex(str) {
     return `0x${Buffer.from(str, 'utf-8').toString('hex')}`;
}

function decodeHex(str) {
     if (str.startsWith('0x')) {
         str = str.slice(2);
     }
     return `${Buffer.from(str, 'hex').toString('utf-8')}`;
}

module.exports = { encodeHex, decodeHex}
    </code></pre>
    <p>NodeJS can handle this using the built-in <code>Buffer.from</code> in any recent version.</p>
    <p>If you need to do this decoding/encoding at the browser level, both <code>web3.js</code> (for Ethereum) and <a href="https://github.com/joticajulian/koilib" target="_blank" rel="noopener noreferrer">koilib</a> for Koinos provide browser safe helper functions.</p>
    <p>A front end implementation using Koilib might look something like this:</p>
    <pre><code class="language-javascript">
import { utils } from "koilib";

function encodeHex(str) {
     let buffer = new TextEncoder().encode(str);
     return `0x${utils.toHexString(buffer)}`;
}

function decodeHex(str) {
     if (str.startsWith('0x')) {
         str = str.slice(2);
     }
     let buffer = utils.toUint8Array(str);
     return new TextDecoder().decode(buffer);
}
    </code></pre>

    <h3>Events</h3>
    <p>An NFT collection contract is expected to emit certain events.</p>
    <ul>
        <li><code>collections.royalties_event</code> - emitted when <code>set_royalties</code> is used to set royalties</li>
        <li><code>collections.owner_event</code> - emitted when ownership is transferred to another address</li>
        <li><code>collections.mint_event</code> - emitted when a new NFT (or NFTs) is minted</li>
        <li><code>collections.transfer_event</code> - emitted when an NFT is transferred</li>
        <li><code>collections.token_approval_event</code> - emitted when approval is given to transfer an NFT to another wallet from another contract (such as a marketplace)</li>
    </ul>

    <h3>Burning NFTs</h3>
    <p>While the concept of burning is part of the <code>KCS-1</code> token standard, it is not in <code>KCS-2</code>. The reason for this is so that the supply stays the same and the <code>MAX_SUPPLY</code> is always constant. If you want to "burn" a particular NFT so that it can no longer be accessed and used, you should instead transfer it to the standard burn account address.</p>

    <h3>Where to find and how to use</h3>
    <p>There is a reference implementation for launching a NFT collection following this standard <a href="https://github.com/kollection-nft/collection-base" target="_blank" rel="noopener noreferrer">available here</a>. It uses the AssemblyScript SDK which you can read more about <a href="https://docs.koinos.io/quickstart/contract-developer-guide/" target="_blank" rel="noopener noreferrer">here</a> in the official Koinos smart contract developer documentation.</p>

    <h3>References</h3>
    <p>Our implementation is built and extended based on the original example from <a href="https://github.com/roaminro" target="_blank" rel="noopener noreferrer">Roamin</a>'s NFT example contract <a href="https://github.com/roaminro/koinos-sdk-as-examples/tree/main/nft" target="_blank" rel="noopener noreferrer">located here</a>. Thanks Roamin!</p>
</section>

<section id="kcs-3">
    <h2>KCS 3: Token Standard that mimics ERC-20</h2>
    <p><strong class="status">Status:</strong> Final</p>
    <p class="authors"><strong>Authors:</strong> Julián González (<a href="https://github.com/joticajulian" target="_blank" rel="noopener noreferrer">https://github.com/joticajulian</a>)</p>

    <p>A contract standard for tokens on the Koinos blockchain.</p>

    <h3>Long Description</h3>
    <p>This standard is to define how tokens can work on the Koinos blockchain. The functionality is setup to closely mimic the <a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank" rel="noopener noreferrer">ERC-20</a> standard on Ethereum. Tokens on Ethereum have become a common standard and our goal is to provide similar functionality here for Koinos users and developers who have come to expect this basic layer of functionality in a token contract.</p>
    <p>Tokens using this standard may include additional utility and functionality beyond this standard in their smart contracting. This is only a base layer of functionality that is expected.</p>

    <h3>Why</h3>
    <p>The KCS-1 token standard is a good solution for smart wallets but it puts in risks the normal accounts (typical accounts without a contract linked to them) because there are no allowances.</p>
    <p>Let's see an example:</p>
    <ul>
        <li>Alice interacts with a scam contract.</li>
        <li>In the popup to sign the transaction she only sees the operation of this contract: get_airdrop(). She signs the transaction and broadcast it to the blockchain.</li>
        <li>Now this contract is called.</li>
        <li>The scam contract now calls the KOIN contract requesting a transfer of all funds from Alice.</li>
        <li>The KOIN contract is called.</li>
        <li>The KOIN contract calls the <code>check_authority</code> system call to verify if Alice has approved this operation.</li>
        <li>Alice doesn't have a smart contract to resolve authorizations then the blockchain checks the signatures.</li>
        <li>As the transaction is signed by Alice then the KOIN transfer is accepted, causing as a result the execution of the scam.</li>
    </ul>
    <p>The KCS-1 contains a section explaining the authorization process and functionality of <code>check_authority</code>. The problem with this system call is that it is useful only for accounts that have smart wallets to resolve authorizations, but normal accounts are in risk and people should not interact with contracts they don't trust because the popup to sign the transaction will not be able to alert them what will happen behind the scenes (the blockchain also has the <code>broadcast:false</code> option to be able to check events without broadcasting the transaction, but this option has also security risks not covered in this article).</p>
    <p>Take into account that we just mentioned the KOIN contract in the example, but the scam could call all assets at the same time (tokens using KCS-1 standard) and steal them all.</p>

    <h3>How this is solved on ethereum?</h3>
    <p>The <a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank" rel="noopener noreferrer">ERC-20 token</a> from ethereum solves this by the introduction of allowances. Following the previous example, Alice must approve the transfer before calling the scam contract. In simple terms, the popup to sign the transaction will show to Alice that she is authorizing a <code>spender</code> to transfer her tokens. In this way she will know in advance what actions are permitted during the execution of the transaction.</p>

    <h3>What changes between KCS-1 and KCS-3?</h3>
    <p>KCS-3 introduces allowances. At the same time the <code>check_authority</code> system call is not used anymore. As consecuence, if the user has a smart wallet to resolve authorizations it will not be called. If the user wants to use smart wallets then the smart wallet should call the token contract in order to set the allowance.</p>
    <p>For reference, the KCS-4 token standard resolves the security risks mentioned here and takes back the <code>check_authority</code> to be able to use smart wallets to resolve authorizations, but for the present KCS-3 standard this option is removed.</p>

    <h3>Specification</h3>
    <p>At a minimum, a token contract using this standard will include the following methods and unique data:</p>

    <h4>Read methods</h4>

    <h5>name</h5>
    <p>Returns the name of the token. No arguments required.</p>
    <p>Protobuf definition</p>
    <pre><code class="language-protobuf">
// Arguments
message name_arguments {}
// Result
message name_result {
    string value = 1;
}
    </code></pre>

    <h5>symbol</h5>
    <p>Returns the symbol for the token. No arguments required.</p>
    <p>Protobuf definition</p>
    <pre><code class="language-protobuf">
// Arguments
message symbol_arguments {}
// Result
message symbol_result {
    string value = 1;
}
    </code></pre>

    <h5>decimals</h5>
    <p>Returns the decimal precision of the token. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message decimals_arguments {}
// Result
message decimals_result {
    uint32 value = 1;
}
    </code></pre>

    <h5>total_supply</h5>
    <p>Returns the total supply of the token. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message total_supply_arguments {}
// Result
message total_supply_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>balance_of</h5>
    <p>Returns how many tokens a specific address holds.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message balance_of_arguments {
    bytes owner = 1 [(btype) = ADDRESS];
}
// Result
message balance_of_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>get_info (optional)</h5>
    <p>Returns name, symbol, and decimals in a single call.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message get_info_arguments {}
// Result
message get_info_result {
    string name = 1;
    string symbol = 2;
    uint32 decimals = 3;
};
    </code></pre>

    <h5>allowance</h5>
    <p>Returns the allowance defined for a specific account.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message allowance_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes spender = 2 [(koinos.btype) = ADDRESS];
}
// Result
message allowance_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>get_allowances</h5>
    <p>Returns a paginated list of allowances defined in an account.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
enum direction {
    ascending = 0;
    descending = 1;
}

message spender_value {
    bytes spender = 1 [(koinos.btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
}

// Arguments
message get_allowances_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes start = 2 [(koinos.btype) = ADDRESS];
    int32 limit = 3;
    direction direction = 4;
}

// Result
message get_allowances_result {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    repeated spender_value allowances = 2;
}
    </code></pre>

    <h4>Write methods</h4>

    <h5>mint</h5>
    <p>Used by the contract owner to initially mint the token to a given address.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message mint_arguments {
    bytes to = 1 [(btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
}
// Result
message mint_result {}
    </code></pre>
    <p>The method should emit a <code>mint_event</code> upon success. The event should indicate the recipient of the mint as an impacted account. The name of the event must be <code>token.mint_event</code>.</p>
    <pre><code class="language-protobuf">
// Event
message mint_event {
    bytes to = 1 [(btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
}
    </code></pre>

    <h5>transfer</h5>
    <p>This will transfer tokens to a new owner. <strong>Note:</strong> The description mentions authorization via <code>check_authority</code>, which contradicts the main explanation of KCS-3 using allowances instead. This likely needs correction in the source.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message transfer_arguments {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    bytes to = 2 [(koinos.btype) = ADDRESS];
    uint64 value = 3 [jstype = JS_STRING];
}
// Result
message transfer_result {}
    </code></pre>
    <p>The transfer event should emit a <code>transfer_event</code> upon success. The event should indicate the receiver and then the sender as impacted accounts. The name of the event must be <code>token.transfer_event</code>.</p>
    <pre><code class="language-protobuf">
// Event
message transfer_event {
    bytes from = 1 [(btype) = ADDRESS];
    bytes to = 2 [(btype) = ADDRESS];
    uint64 value = 3 [jstype = JS_STRING];
}
    </code></pre>

    <h5>burn (optional)</h5>
    <p>Burns an amount of token from an address. <strong>Note:</strong> The description mentions authorization via <code>check_authority</code>, which contradicts the main explanation of KCS-3 using allowances instead. This likely needs correction in the source.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message burn_arguments {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
}
// Result
message burn_result {}
    </code></pre>
    <p>The method should emit a <code>burn_event</code> upon success. The event should indicate the source as an impacted account. The name of the event must be <code>token.burn_event</code>.</p>
    <pre><code class="language-protobuf">
// Event
message burn_event {
    bytes from = 1 [(btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
}
    </code></pre>

    <h5>approve</h5>
    <p>Grant permissions to other account to manage the tokens owned by the user.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message approve_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes spender = 2 [(koinos.btype) = ADDRESS];
    uint64 value = 3 [jstype = JS_STRING];
}
// Result
message approve_result {}
    </code></pre>
    <p>The method should emit an <code>approve_event</code> upon success. The event should indicate the spender and then the owner as the impacted accounts. The name of the event must be <code>token.approve_event</code>.</p>
    <pre><code class="language-protobuf">
// Event
message approve_event {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes spender = 2 [(koinos.btype) = ADDRESS];
    uint64 value = 3 [jstype = JS_STRING];
}
    </code></pre>

    <h3>Expected Unique Data and Types</h3>
    <p>With the proposed implementation developers would set the following constants before uploading their token contract:</p>
    <ul>
        <li><code>NAME</code> - a string for the human readable name of the token.</li>
        <li><code>SYMBOL</code> - a string for the symbol or ticker used for the token (all uppercase).</li>
        <li><code>DECIMALS</code> - a u32 for the decimal precision of the token.</li>
    </ul>

    <h3>Implementation</h3>
    <p>The implementation of this token contract can be found at:</p>
    <ul>
        <li><a href="https://github.com/joticajulian/koinos-contracts-as/blob/v1.2.4/contracts/token/assembly/Token.ts" target="_blank" rel="noopener noreferrer">Token contract v1.0.3 - @koinosbox/contracts@v1.2.4</a>.</li>
    </ul>

    <h3>References</h3>
    <ul>
        <li><a href="https://peakd.com/koinos/@jga/improve-security-koinos" target="_blank" rel="noopener noreferrer">Improve security in koinos (by @jga)</a>.</li>
    </ul>
</section>

<section id="kcs-4">
    <h2>KCS 4: Token Standard that mimics ERC-20 and supports Koinos authority system</h2>
    <p><strong class="status">Status:</strong> Pending</p>
    <p class="authors"><strong>Authors:</strong> Julián González (<a href="https://github.com/joticajulian" target="_blank" rel="noopener noreferrer">https://github.com/joticajulian</a>)</p>

    <p>A contract standard for tokens on the Koinos blockchain.</p>
    <blockquote><p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="https://www.rfc-editor.org/rfc/rfc2119" target="_blank" rel="noopener noreferrer">RFC 2119</a>.</p></blockquote>

    <h3>Long Description</h3>
    <p>This standard is to define how tokens can work on the Koinos blockchain. The functionality is setup to closely mimic the <a href="https://eips.ethereum.org/EIPS/eip-20" target="_blank" rel="noopener noreferrer">ERC-20</a> standard on Ethereum. At the same time, it supports the Koinos authority system, which is useful for smart wallets.</p>

    <h3>Why</h3>
    <p>This standard takes the best of the token standards KCS-1 and KCS-3. On one hand, the KCS-1 is useful for smart wallets by using the Koinos authority system, however it puts in risk the normal accounts. On the other hand, the KCS-3 resolves the risks of normal accounts but it ignores the Koinos authority system.</p>
    <p>The difficulty of merging both standards is because before 2024-02-12 there was not possible to classify accounts by type (smart wallets / normal accounts) inside the token contract. But now this is possible thanks to <code>get_contract_metadata</code> system call, then the KCS-4 token standard have allowances to put normal accounts in safe place and supports the Koinos authority system for smart wallets.</p>

    <h3>Allowance and check authority</h3>

    <h4>Authorization</h4>
    <p>Authorization is a key component of this standard. There is a more complex authority check that is used by most functions. For ease of implementation, the AS-SDK v1.2.0 and newer contains the function <code>System.checkAccountAuthority</code> which implements the new logic. By default</p> <p>The function to verify authorizations is extended in this way:</p>
    <ol>
        <li>Check if the caller of the operation is allowed to do it by checking the allowances.</li>
        <li>If the contract caller is the owner of the tokens then the operation is accepted.</li>
        <li>If there is a contract caller AND the owner doesn't have a contract to resolve authorizations then the operation is rejected.</li>
        <li>If the points above do not apply then use the native check authority function:
            <ol type="a">
                <li>If the owner has a smart contract to resolve authorizations then call it.</li>
                <li>If the owner does not have a smart contract then check if the transaction is signed by the owner.</li>
            </ol>
        </li>
    </ol>
    <p>Consider the case where the owner uses a normal account (not smart wallet). If he interacts directly with the token contract then the signature will be validated (point 4.b). If he interacts with a DEX and the DEX makes a transfer in name of the owner then the allowance will be validated (point 1), otherwise it will be rejected (point 3). In this way allowances protect the assets of the users, because they have to set them in advance before a third contract tries to execute a transfer.</p>
    <p>Now consider the case where the owner has a smart wallet. Consider also that he does not set any allowance in the token contract. If he interacts directly with the token contract then the smart wallet will be called (point 4.a). If he interacts with a DEX and the DEX makes a transfer in name of the owner then the smart wallet will be called as well (point 4.a). This means that the token contract supports the Koinos authority system, which is useful for smart wallets.</p>
    <p>This authorization is required for <code>transfer</code> and <code>burn</code>. Steps 2-4 are required for <code>approve</code>. For ease of implementation, the AS-SDK v1.2.0 and newer contains the function <code>System.checkAccountAuthority</code> which implements steps 2-4 outlines above. In addition, the existing function <code>System.requireAuthority</code> has an additional parameter for enhanced security that will call <code>checkAccountAuthority</code>. By default, <code>requireAuthority</code> will use the enhanced security, so any contract already using <code>requireAuthority</code> can take advantage of the improved security outlined above by simply upgrading their SDK version.</p>

    <h3>Specification</h3>
    <p>At a minimum, a token contract using this standard must include the following methods and events. Some methods in this specification are optional and are documented accordingly.</p>
    <p>A token contract should check inputs and return meaningful error messages. For example, if a transfer argument does not contain one of the addresses should exit with a meaningful error message.</p>

    <h4>Memos</h4>
    <p>Some functions allow for user specified memos. These are <code>mint</code>, <code>transfer</code>, <code>burn</code>, and <code>approve</code>. For the purposes of this specification, they are not intended for internal use by a token, but are there for protocols external to the blockchain to take advantage of. Please follow these guidelines for all <code>memo</code> fields.</p>
    <p>The memo field is optional for the user, but must be supported by the contract. The contents of the memo must not be error checked as the contents could include non-ASCII characters such as Unicode for international messages or the entire byte range for encrypted/encoded messages.</p>
    <p>If a user provides a memo, it must be included in the corresponding event (e.g. If a memo is present on <code>transfer_arguments</code> it must be present on the corresponding <code>transfer_event</code> if the transfer succeeds).</p>

    <h4>Read methods</h4>

    <h5>name</h5>
    <p>Returns the name of the token. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message name_arguments {}
// Result
message name_result {
    string value = 1;
}
    </code></pre>

    <h5>symbol</h5>
    <p>Returns the symbol for the token. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message symbol_arguments {}
// Result
message symbol_result {
    string value = 1;
}
    </code></pre>

    <h5>decimals</h5>
    <p>Returns the decimal precision of the token. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message decimals_arguments {}
// Result
message decimals_result {
    uint32 value = 1;
}
    </code></pre>

    <h5>total_supply</h5>
    <p>Returns the total supply of the token. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message total_supply_arguments {}
// Result
message total_supply_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>balance_of</h5>
    <p>Returns how many tokens a specific address holds.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message balance_of_arguments {
    bytes owner = 1 [(btype) = ADDRESS];
}
// Result
message balance_of_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>get_info (optional)</h5>
    <p>Returns name, symbol, and decimals in a single call.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message get_info_arguments {}
// Result
message get_info_result {
    string name = 1;
    string symbol = 2;
    uint32 decimals = 3;
};
    </code></pre>

    <h5>allowance</h5>
    <p>Returns the allowance defined for a specific account.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message allowance_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes spender = 2 [(koinos.btype) = ADDRESS];
}
// Result
message allowance_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>get_allowances</h5>
    <p>Returns a paginated list of allowances defined in an account.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
message spender_value {
    bytes spender = 1 [(koinos.btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
}

// Arguments
message get_allowances_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes start = 2 [(koinos.btype) = ADDRESS];
    int32 limit = 3;
    bool descending = 4;
}

// Result
message get_allowances_result {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    repeated spender_value allowances = 2;
}
    </code></pre>

    <h4>Write methods</h4>

    <h5>mint</h5>
    <p>Used by the contract owner to initially mint the token to a given address. Authorization of the mint function is left up to the developer. Most contracts will require the contract itself to authorize (sign with the key associated with the contract) or delegate to another address that is either another contract or an address the developer controls.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message mint_arguments {
    bytes to = 1 [(btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
    optional string memo = 3;
}
// Result
message mint_result {}
    </code></pre>
    <p>The method must emit a <code>mint_event</code> upon success. The event must indicate the recipient of the mint as an impacted account. The name of the event must be <code>token.mint_event</code>.</p>
    <pre><code class="language-protobuf">
// Event
message mint_event {
    bytes to = 1 [(btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
    optional string memo = 3;
}
    </code></pre>

    <h5>transfer</h5>
    <p>This will transfer tokens to a new owner. Transfer is authorized by the improved authority outlined <a href="#kcs-4-authorization">above</a>.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message transfer_arguments {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    bytes to = 2 [(koinos.btype) = ADDRESS];
    uint64 value = 3 [jstype = JS_STRING];
    optional string memo = 4;
}
// Result
message transfer_result {}
    </code></pre>
    <p>The transfer event must emit a <code>transfer_event</code> upon success. The event must indicate the receiver and then the sender as impacted accounts. The name of the event must be <code>token.transfer_event</code>. If a memo is provided by the user, it must be included in the event.</p>
    <pre><code class="language-protobuf">
// Event
message transfer_event {
    bytes from = 1 [(btype) = ADDRESS];
    bytes to = 2 [(btype) = ADDRESS];
    uint64 value = 3 [jstype = JS_STRING];
    optional string memo = 4;
}
    </code></pre>

    <h5>burn (optional)</h5>
    <p>Burns an amount of token from an address. Burn is authorized by the improved authority outlined <a href="#kcs-4-authorization">above</a>.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message burn_arguments {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
    optional string memo = 3;
}
// Result
message burn_result {}
    </code></pre>
    <p>The method must emit a <code>burn_event</code> upon success. The event must indicate the source as an impacted account. The name of the event must be <code>token.burn_event</code>.</p>
    <pre><code class="language-protobuf">
// Event
message burn_event {
    bytes from = 1 [(btype) = ADDRESS];
    uint64 value = 2 [jstype = JS_STRING];
    optional string memo = 3;
}
    </code></pre>

    <h5>approve</h5>
    <p>Grant permissions to other account to manage the tokens owned by the user. Approve is authorized by the improved authority outlined <a href="#kcs-4-authorization">above</a>.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message approve_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes spender = 2 [(koinos.btype) = ADDRESS];
    uint64 value = 3 [jstype = JS_STRING];
    optional string memo = 4;
}
// Result
message approve_result {}
    </code></pre>
    <p>The method must emit an <code>approve_event</code> upon success. The event must indicate the spender and then the owner as the impacted accounts. The name of the event must be <code>token.approve_event</code>.</p>
    <pre><code class="language-protobuf">
// Event
message approve_event {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes spender = 2 [(koinos.btype) = ADDRESS];
    uint64 value = 3 [jstype = JS_STRING];
    optional string memo = 4;
}
    </code></pre>

    <h5>authorize (optional)</h5>
    <p>Optionally, token contracts can implement an authorize override that defaults to System authority using <code>System.checkSystemAuthority</code>. This allows any tokens inadvertently sent to the token contract itself to be retrieved and sent to their rightful owner via a governance proposal.</p>

    <h3>Implementation</h3>
    <p>The implementation of this token contract can be found at:</p>
    <ul>
        <li><a href="https://github.com/joticajulian/koinos-contracts-as/blob/v2.0.2/contracts/token/assembly/Token.ts" target="_blank" rel="noopener noreferrer">Token contract v1.0.2 - @koinosbox/contracts@v2.0.2</a> (check also latest updates).</li>
    </ul>
    <p>With this example implementation developers would set the following constants before uploading their token contract:</p>
    <ul>
        <li><code>NAME</code> - a string for the human readable name of the token.</li>
        <li><code>SYMBOL</code> - a string for the symbol or ticker used for the token (all uppercase).</li>
        <li><code>DECIMALS</code> - a u32 for the decimal precision of the token.</li>
    </ul>

    <h3>References</h3>
    <ul>
        <li><a href="https://peakd.com/koinos/@jga/check-authority-2-testnet" target="_blank" rel="noopener noreferrer">New system call in koinos - part1 (by @jga)</a>.</li>
        <li><a href="https://peakd.com/koinos/@jga/new-koinos-system-call-live-in-the-testnet" target="_blank" rel="noopener noreferrer">New system call in koinos - part2 (by @jga)</a></li>
    </ul>
</section>

<section id="kcs-5">
    <h2>KCS 5: NFT Standard that mimics ERC-721 and supports Koinos authority system</h2>
    <p><strong class="status">Status:</strong> Pending</p>
    <p class="authors"><strong>Authors:</strong> Julián González (<a href="https://github.com/joticajulian" target="_blank" rel="noopener noreferrer">https://github.com/joticajulian</a>)</p>

    <p>A contract standard for NFT collections on the Koinos blockchain.</p>
    <blockquote><p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.</p></blockquote>

    <h3>Long Description</h3>
    <p>This standard is to define how NFT collections can work on the Koinos blockchain. The functionality mimic the <a href="https://eips.ethereum.org/EIPS/eip-721" target="_blank" rel="noopener noreferrer">ERC-721</a> standard on Ethereum and extend it with new features. At the same time, it supports the Koinos authority system, which is useful for smart wallets.</p>

    <h3>Why</h3>
    <p>This standard introduces new features with respect to the standard KCS-2. Here is a summary of the principal changes:</p>
    <ol>
        <li><strong>Possibility to store metadata onchain</strong>. When the <code>uri</code> is defined or <code>token_uri</code> endpoint is used then the metadata is stored off-chain. However, if the <code>uri</code> is undefined and <code>token_uri</code> endpoint does not exist the metadata must be obtained from onchain from <code>metadata_of</code>. Thanks to this option, the developers don't have to setup an API for the contract.</li>
        <li><strong>Function to get a paginated list of NFTs</strong>. One of the main barriers of the ERC-721 and KCS-2 is that it's not possible know what is the list of NFTs in the collection, unless you setup a microservice that listen changes in the contract, or you rely in third parties offering this functionality. KCS-5 adds the paginated <code>get_tokens</code> and <code>get_tokens_by_owner</code> calls.</li>
        <li><strong>Function to list approvals</strong>. This feature allows users to know what are the approvals they have set to third parties. In this sense, they will have more control on their assets.</li>
        <li><strong>Koinos System Authority</strong>. Introduction of the new system call in Koinos to be able to classify accounts by type, in order to give safety to the users that don't have smart wallets and at the same time be able to call users' contracts to resolve authorities in case they use smart wallets.</li>
    </ol>

    <h3>Allowance and check authority</h3>
    <p>The function to verify authorizations is extended in this way:</p>
    <ol>
        <li>Check if the caller of the operation is allowed to do it by checking the allowances (approval of a single NFT, or approval for all NFTs).</li>
        <li>If the contract caller is the owner of the NFT then the operation is accepted.</li>
        <li>If there is a contract caller AND the owner doesn't have a contract to resolve authorizations then the operation is rejected.</li>
        <li>If the points above do not apply then use the native check authority function:
            <ol type="a">
                <li>If the owner has a smart contract to resolve authorizations then call it.</li>
                <li>If the owner does not have a smart contract then check if the trasaction is signed by the owner.</li>
            </ol>
        </li>
    </ol>
    <p>Consider the case where the owner uses a normal account (not smart wallet). If he interacts directly with the NFT contract then the signature will be validated (point 4.b). If he interacts with a DEX and the DEX makes a transfer in name of the owner then the allowance will be validated (point 1), otherwise it will be rejected (point 3). In this way allowances protect the assets of the users, because they have to set them in advance before a third contract tries to execute a transfer.</p>
    <p>Now consider the case where the owner has a smart wallet. Consider also that he does not set any allowance in the NFT contract. If he interacts directly with the NFT contract then the smart wallet will be called (point 4.a). If he interacts with a DEX and the DEX makes a transfer in name of the owner then the smart wallet will be called as well (point 4.a). This means that the NFT contract supports the Koinos authority system, which is useful for smart wallets.</p>

    <h3>Specification</h3>
    <p>At a minimum, a NFT contract using this standard will include the following methods and unique data:</p>

    <h4>Read methods</h4>

    <h5>name</h5>
    <p>Returns the name of the NFT. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message name_arguments {}
// Result
message name_result {
    string value = 1;
}
    </code></pre>

    <h5>symbol</h5>
    <p>Returns the symbol for the NFT. No arguments required.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message symbol_arguments {}
// Result
message symbol_result {
    string value = 1;
}
    </code></pre>

    <h5>uri</h5>
    <p>Returns the endpoint to resolve the metadata. If the uri is empty and <code>token_uri</code> is not used then <code>metadata_of</code> must return the metadata of the NFT.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message uri_arguments {}
// Result
message uri_result {
    string value = 1;
}
    </code></pre>

    <h5>token_uri</h5>
    <p>Returns the endpoint for an individual token to resolve the metadata. If the uri is empty and <code>token_uri</code> is not used then <code>metadata_of</code> must return the metadata of the NFT.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message token_uri_arguments {
    bytes token_id = 1 [(koinos.btype) = HEX];
}
// Result
message token_uri_result {
    string value = 1;
}
    </code></pre>

    <h5>get_info (optional)</h5>
    <p>Returns name, symbol, decimals, and description in a single call.</p> <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message get_info_arguments {}
// Result
message get_info_result {
    string name = 1;
    string symbol = 2;
    uint32 uri = 3; // Note: Source says uint32 uri, likely meant string uri or similar
    string description = 4;
};
    </code></pre>

    <h5>owner</h5>
    <p>Returns the owner of the collection.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message owner_arguments {}
// Result
message owner_result {
    bytes value = 1 [(koinos.btype) = ADDRESS];
}
    </code></pre>

    <h5>total_supply</h5>
    <p>Returns the total supply of the NFT collection.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message total_supply_arguments {}
// Result
message total_supply_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>royalties</h5>
    <p>Returns the royalties configuration.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
message royalty {
    uint64 percentage = 1 [jstype = JS_STRING];
    bytes address = 2 [(koinos.btype) = ADDRESS];
}
// Arguments
message royalties_arguments {}
// Result
message royalties_result {
    repeated royalty value = 1;
}
    </code></pre>

    <h5>balance_of</h5>
    <p>Returns how many NFTs a specific address holds.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message balance_of_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
}
// Result
message balance_of_result {
    uint64 value = 1 [jstype = JS_STRING];
}
    </code></pre>

    <h5>owner_of</h5>
    <p>Returns the owner of a specific NFT.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message owner_of_arguments {
    bytes token_id = 1 [(koinos.btype) = HEX];
}
// Result
message owner_of_result {
    bytes value = 1 [(koinos.btype) = ADDRESS];
}
    </code></pre>

    <h5>metadata_of</h5>
    <p>Returns the metadata of a specific NFT. If the metadata is empty then <code>URI</code> must return an endpoint to retrieve the metadata.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message metadata_of_arguments {
    bytes token_id = 1 [(koinos.btype) = HEX];
}
// Result
message metadata_of_result {
    string value = 1;
}
    </code></pre>

    <h5>get_tokens</h5>
    <p>Returns a paginated list of NFTs in the collection.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message get_tokens_arguments {
    bytes start = 1 [(koinos.btype) = HEX];
    int32 limit = 2;
    bool descending = 3;
}
// Result
message get_tokens_result {
    repeated bytes values = 1 [(koinos.btype) = HEX];
}
    </code></pre>

    <h5>get_tokens_by_owner</h5>
    <p>Returns a paginated list of NFTs owned by a specific account.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message get_tokens_by_owner_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes start = 2 [(koinos.btype) = HEX];
    int32 limit = 3;
    bool descending = 4;
}
// Result
message get_tokens_by_owner_result {
    repeated bytes values = 1 [(koinos.btype) = HEX];
}
    </code></pre>

    <h5>get_approved</h5>
    <p>Returns the account allowed to operate a specific NFT (apart from the owner).</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message get_approved_arguments {
    bytes token_id = 1 [(koinos.btype) = HEX];
    bytes start = 2 [(koinos.btype) = ADDRESS];
    uint32 limit = 3;
    bool descending = 4;
}
// Result
message get_approved_result {
    bytes value = 1 [(koinos.btype) = ADDRESS];
    repeated bytes values = 2 [(koinos.btype) = ADDRESS];
}
    </code></pre>
    <p>This is a paginated API, but to support backwards compatibility, it should behave in the following way. For KCS-2, <code>start</code>, <code>limit</code>, and <code>descending</code> are not present. The contract must detect this scenario and in that case return the first address in the <code>value</code> field.</p>
    <p>Single token approvals can be handled in one of two ways. In KCS-2, a token could only have one address approved at a time (separate from addresses approved for all tokens). KCS-5 can continue working in this way, but can also support multiple approvals per token. If multiple approvals per token are allowed then then the first value should be sent in the <code>value</code> field and the entire result can be returned in <code>values</code>.</p>

    <h5>is_approved_for_all</h5>
    <p>Returns if an account is authorized to operate all NFTs of a specific owner.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message is_approved_for_all_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes operator = 2 [(koinos.btype) = ADDRESS];
}
// Return
message is_approved_for_all_result {
    bool value = 1;
}
    </code></pre>

    <h5>get_operator_approvals</h5>
    <p>Returns a paginated list of all accounts allowed to operate all NFTs of a specific owner.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message get_operator_approvals_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes start = 2 [(koinos.btype) = ADDRESS];
    int32 limit = 3;
    bool descending = 4;
}
// Return
message get_operator_approvals_result {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    repeated bytes operators = 2 [(koinos.btype) = ADDRESS];
}
    </code></pre>

    <h4>Write methods</h4>

    <h5>transfer_ownership</h5>
    <p>Function to transfer the ownership of the collection to other account. Only the owner of the collection can perform this operation.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message transfer_ownership_arguments {
    bytes to = 1 [(koinos.btype) = ADDRESS];
}
// Result
message transfer_ownership_result {}
    </code></pre>
    <p>The method should emit <code>owner_event</code> upon success with the name <code>collections.owner_event</code>. The event should indicate the new owner and then the previous owner as impacted accounts.</p>
    <pre><code class="language-protobuf">
// Event
message owner_event {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    bytes to = 2 [(koinos.btype) = ADDRESS];
}
    </code></pre>

    <h5>set_royalties</h5>
    <p>Function to set the royalties. Only the owner of the collection can perform this operation.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
message royalty {
    uint64 percentage = 1 [jstype = JS_STRING];
    bytes address = 2 [(koinos.btype) = ADDRESS];
}
// Arguments
message set_royalties_argument {
    repeated royalty value = 1;
}
// Result
message set_royalties_result {}
    </code></pre>
    <p>The method should emit <code>royalties_event</code> upon success with the name <code>collections.royalties_event</code>. The event should indicate the addresses of the royalties as impacted accounts.</p>
    <pre><code class="language-protobuf">
// Event
message royalties_event {
    repeated royalty value = 1;
}
    </code></pre>

    <h5>set_metadata</h5>
    <p>Function to set the metadata of the tokens. It should be a JSON converted to string.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message set_metadata_arguments {
    bytes token_id = 1 [(koinos.btype) = HEX];
    string metadata = 2;
}
// Result
message set_metadata_result {}
    </code></pre>
    <p>The method should emit <code>set_metadata_event</code> upon success with the name <code>collections.set_metadata_event</code>. The event should indicate the source as an impacted account.</p>
    <pre><code class="language-protobuf">
// Event
message set_metadata_event {
    bytes token_id = 1 [(koinos.btype) = HEX];
    string metadata = 2;
}
    </code></pre>

    <h5>approve</h5>
    <p>Grant permissions to other account to manage the NFTs owned by the user.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message approve_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS, deprecated = true];
    bytes operator = 2 [(koinos.btype) = ADDRESS];
    bytes token_id = 3 [(koinos.btype) = HEX];
    optional string memo = 4;
    optional bool approve = 5;
}
// Result
message approve_result {}
    </code></pre>
    <p>The method should emit <code>token_approval_event</code> upon success with the name <code>collections.token_approval_event</code>. The event should indicate the approved address and then the owner address as impacted accounts.</p>
    <p>The <code>owner</code> field is deprecated, but present to preserve wire compatibility with KCS-2. When interacting with KCS-5, a user may choose to ignore the field, but if not and the owner does not match the token owner, an error MUST be returned regardless of whether the actual owner authorized the transaction.</p>
    <p>The <code>approve</code> field is optional because KCS-2 implies approval using this method. Because it is optional, <code>approve</code> can be one of three states, true, false, and not set. If not set, then the operation should be treated as if <code>approve</code> was set to true.</p>
    <pre><code class="language-protobuf">
// Event
message token_approval_event {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes operator = 2 [(koinos.btype) = ADDRESS];
    bytes token_id = 3 [(koinos.btype) = HEX];
    optional string memo = 4;
    optional bool approve = 5;
}
    </code></pre>

    <h5>set_approval_for_all</h5>
    <p>Grant permissions to other account to manage all Tokens owned by the user.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message set_approval_for_all_arguments {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes operator = 2 [(koinos.btype) = ADDRESS];
    bool approved = 3;
    optional string memo = 4;
}
// Result
message set_approval_for_all_result {}
    </code></pre>
    <p>The method should emit <code>operator_approval_event</code> upon success with the name <code>collections.operator_approval_event</code>. The event should indicate the operator address and then the owner address as impacted accounts.</p>
    <pre><code class="language-protobuf">
// Event
message operator_approval_event {
    bytes owner = 1 [(koinos.btype) = ADDRESS];
    bytes operator = 2 [(koinos.btype) = ADDRESS];
    bool approved = 3;
    optional string memo = 4;
}
    </code></pre>

    <h5>mint</h5>
    <p>Used by the contract owner to initially mint the NFT to a given address.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message mint_arguments {
    bytes to = 1 [(koinos.btype) = ADDRESS];
    bytes token_id = 2 [(koinos.btype) = HEX];
    optional string memo = 3;
}
// Result
message mint_result {}
    </code></pre>
    <p>The method should emit <code>mint_event</code> upon success with the name <code>collections.mint_event</code>. The event should indicate the recipient of the mint as an impacted account.</p>
    <pre><code class="language-protobuf">
// Event
message mint_event {
    bytes to = 1 [(koinos.btype) = ADDRESS];
    bytes token_id = 2 [(koinos.btype) = HEX];
    optional string memo = 3;
}
    </code></pre>

    <h5>transfer</h5>
    <p>This will transfer an NFT to a new owner. The authorization is checked using allowances and/or smart wallets as explained above.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message transfer_arguments {
    bytes from = 1 [(koinos.btype) = ADDRESS, deprecated = true];
    bytes to = 2 [(koinos.btype) = ADDRESS];
    bytes token_id = 3 [(koinos.btype) = HEX];
    optional string memo = 4;
}
message transfer_result {}
    </code></pre>
    <p>The method should emit <code>transfer_event</code> upon success with the name <code>collections.transfer_event</code>. The event should indicate the receiver and then the sender as impacted accounts.</p>
    <p>The <code>from</code> field is deprecated, but present to preserve wire compatibility with KCS-2. When using KCS-5, the user may choose to ignore the field, but if not and the owner does not match the token owner, an error must be returned regardless of whether the actual owner authorized the transaction.</p>
    <pre><code class="language-protobuf">
// Event
message transfer_event {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    bytes to = 2 [(koinos.btype) = ADDRESS];
    bytes token_id = 3 [(koinos.btype) = HEX];
    optional string memo = 4;
}
    </code></pre>

    <h5>burn (optional)</h5>
    <p>Burns an amount of NFT from an address. The authorization is checked using allowances and/or smart wallets as explained above.</p>
    <p>Protobuf definition:</p>
    <pre><code class="language-protobuf">
// Arguments
message burn_arguments {
    bytes token_id = 1 [(koinos.btype) = HEX];
    optional string memo = 2;
}
// Result
message burn_result {}
    </code></pre>
    <p>The method should emit <code>burn_event</code> upon success with the name <code>collections.burn_event</code>. The event should indicate the previous owner as an impacted account.</p>
    <pre><code class="language-protobuf">
// Event
message burn_event {
    bytes from = 1 [(koinos.btype) = ADDRESS];
    bytes token_id = 2 [(koinos.btype) = HEX];
    optional string memo = 3;
}
    </code></pre>

    <h3>Expected Unique Data and Types</h3>
    <p>With the proposed implementation developers would set the following constants before uploading their NFT contract:</p>
    <ul>
        <li><code>NAME</code> - a string for the human readable name of the NFT collection.</li>
        <li><code>SYMBOL</code> - a string for the symbol or ticker used for the NFT (all uppercase).</li>
        <li><code>URI</code> - a string that contains the metadata URI (can be ipfs or https). When the metadata is stored onchain it should be empty.</li>
    </ul>

    <h3>Implementation</h3>
    <p>The implementation of this NFT contract can be found at:</p>
    <ul>
        <li><a href="https://github.com/joticajulian/koinos-contracts-as/blob/v2.0.2/contracts/nft/assembly/Nft.ts" target="_blank" rel="noopener noreferrer">Nft contract v2.0.2 - @koinosbox/contracts@v2.0.2</a> (check also latest updates).</li>
    </ul>
</section>

</body>
</html>
